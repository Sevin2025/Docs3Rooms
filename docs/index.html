<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Галерея — Docs3Rooms</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #descriptionBox {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px;
      max-width: 600px; display: none; z-index: 100;
    }
    #instructions {
      position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7);
      color: white; padding: 10px; border-radius: 5px; font-size: 14px; z-index: 100;
    }
    button { margin: 5px; padding: 8px 12px; }
  </style>
</head>
<body>
  <div id="instructions">
    <div>ПКМ — захват курсора | WASD — движение | Q/E — поворот 90° | Клик — повернуться к картине | Двойной клик — подойти</div>
  </div>
  <div id="descriptionBox">
    <div id="descTitle" style="font-weight:bold; margin-bottom:8px;"></div>
    <div id="descText"></div>
  </div>

  <script type="module">
    import * as THREE from './assets/three/three.module.js';
    import { PointerLockControls } from './assets/three/PointerLockControls.js';

    // === Конфигурация комнаты ===
    const ROOM = { w: 10, d: 8, h: 3 }; // ширина, глубина, высота
    const WALL_MARGIN = 0.4; // отступ картин от углов
    const MIN_DISTANCE_TO_WALL = 0.6;

    // === Сцены, камера, рендерер ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 1.7, 0); // рост человека

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // === Освещение ===
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 5, 5);
    scene.add(dirLight);

    // === Пол и потолок ===
    const floorGeo = new THREE.PlaneGeometry(ROOM.w, ROOM.d);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    const ceiling = new THREE.Mesh(floorGeo, new THREE.MeshStandardMaterial({ color: 0x222222 }));
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    // === Стены и картины ===
    const textureLoader = new THREE.TextureLoader();
    const paintingPlanes = [];
    const descriptions = await fetchJSON('./assets/descriptions.json');

    function fetchJSON(url) {
      return fetch(url).then(r => r.ok ? r.json() : {});
    }

    function createWallWithPaintings(wallName, position, rotation, paintings, isLeftOrRight) {
      const wallGeo = new THREE.PlaneGeometry(
        isLeftOrRight ? ROOM.d : ROOM.w,
        ROOM.h
      );
      const wallMat = new THREE.MeshStandardMaterial({ color: 0xdddddd });
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.copy(position);
      wall.rotation.y = rotation;
      scene.add(wall);

      // Картины на стене
      const wallLength = isLeftOrRight ? ROOM.d : ROOM.w;
      const availableLength = wallLength - 2 * WALL_MARGIN;
      const totalPaintings = paintings.length;
      const paintingWidth = availableLength / totalPaintings;

      paintings.forEach((file, i) => {
        const tex = textureLoader.load(`./assets/${file}`, tex => {
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        });

        const aspect = 1; // предполагаем квадратные картины; можно улучшить
        const paintingHeight = paintingWidth / aspect;
        const paintingGeo = new THREE.PlaneGeometry(paintingWidth, paintingHeight);
        const paintingMat = new THREE.MeshBasicMaterial({ map: tex });
        const painting = new THREE.Mesh(paintingGeo, paintingMat);

        const x = -wallLength / 2 + WALL_MARGIN + i * paintingWidth + paintingWidth / 2;
        const z = isLeftOrRight ? 0 : (rotation === 0 ? -0.01 : 0.01);
        const y = ROOM.h / 2;

        if (isLeftOrRight) {
          painting.position.set(position.x, y, x);
          painting.rotation.y = rotation;
        } else {
          painting.position.set(x, y, position.z);
          painting.rotation.y = rotation;
        }

        painting.userData = { file, meta: descriptions[file] || {} };
        scene.add(painting);
        paintingPlanes.push(painting);
      });
    }

    // === Определяем картины по стенам ===
    const wall1Paintings = ['paintingA01.jpg', 'paintingA02.jpg']; // room1 — левая
    const wall2Paintings = ['paintingG01.jpg'];                   // room2 — фронт
    const wall3Paintings = ['paintingS01.jpg'];                   // room3 — правая

    // room1: левая стена (x = -w/2)
    createWallWithPaintings('room1', new THREE.Vector3(-ROOM.w/2, ROOM.h/2, 0), Math.PI / 2, wall1Paintings, true);
    // room2: фронтальная (z = -d/2)
    createWallWithPaintings('room2', new THREE.Vector3(0, ROOM.h/2, -ROOM.d/2), 0, wall2Paintings, false);
    // room3: правая (x = +w/2)
    createWallWithPaintings('room3', new THREE.Vector3(ROOM.w/2, ROOM.h/2, 0), -Math.PI / 2, wall3Paintings, true);

    // === Pointer Lock Controls ===
    const controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    document.body.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => { isPointerLocked = true; });
    controls.addEventListener('unlock', () => { isPointerLocked = false; });

    let isPointerLocked = false;

    // === Управление движением и поворотом ===
    const move = { forward: 0, backward: 0, left: 0, right: 0 };
    const rotateAnim = { target: 0, current: 0 };
    let yaw = 0;
    const rotSpeed = 3; // радиан/сек
    const moveSpeed = 3; // м/с

    const keys = {};
    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    // Поворот по Q/E
    document.addEventListener('keydown', e => {
      if (!isPointerLocked) return;
      if (e.key === 'q') startRotateBy(-Math.PI / 2);
      if (e.key === 'e') startRotateBy(Math.PI / 2);
    });

    function startRotateBy(delta) {
      if (rotateAnim.active) return;
      const target = yaw + delta;
      rotateAnim.target = target;
      rotateAnim.current = yaw;
      rotateAnim.active = true;
      rotateAnim.startTime = performance.now();
    }

    // === Raycaster для кликов ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0, 0);

    function onClick(e) {
      if (!isPointerLocked) return;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(paintingPlanes, false)[0];
      if (hit) startRotateToPainting(hit.object);
    }

    function onDblClick(e) {
      if (!isPointerLocked) return;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(paintingPlanes, false)[0];
      if (hit) approachPainting(hit.object);
    }

    document.addEventListener('click', onClick);
    document.addEventListener('dblclick', onDblClick);

    function startRotateToPainting(obj) {
      const pos = new THREE.Vector3();
      obj.getWorldPosition(pos);
      const dir = pos.clone().sub(camera.position).setY(0).normalize();
      let targetYaw = Math.atan2(dir.x, dir.z);
      // Привязка к 90°
      targetYaw = Math.round(targetYaw / (Math.PI / 2)) * (Math.PI / 2);
      startRotateBy(targetYaw - yaw);
      showDescription(obj.userData);
    }

    function approachPainting(obj) {
      const pos = new THREE.Vector3();
      obj.getWorldPosition(pos);
      const normal = new THREE.Vector3();
      obj.getWorldDirection(normal);
      const targetPos = pos.clone().add(normal.clone().multiplyScalar(-0.8));
      targetPos.y = camera.position.y;

      // Ограничение
      const hw = ROOM.w / 2 - MIN_DISTANCE_TO_WALL;
      const hd = ROOM.d / 2 - MIN_DISTANCE_TO_WALL;
      targetPos.x = Math.max(-hw, Math.min(hw, targetPos.x));
      targetPos.z = Math.max(-hd, Math.min(hd, targetPos.z));

      camera.position.lerp(targetPos, 0.1);
    }

    function showDescription(d) {
      const box = document.getElementById('descriptionBox');
      document.getElementById('descTitle').innerText = d.meta?.title || d.file;
      document.getElementById('descText').innerText =
        (d.meta?.description || 'Описание отсутствует') +
        (d.meta?.author ? `\nАвтор: ${d.meta.author}` : '');
      box.style.display = 'block';
      setTimeout(() => { box.style.display = 'none'; }, 5000);
    }

    // === Анимация ===
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      // Поворот
      if (rotateAnim.active) {
        const t = Math.min((performance.now() - rotateAnim.startTime) / 500, 1);
        const easeT = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        yaw = rotateAnim.current + (rotateAnim.target - rotateAnim.current) * easeT;
        camera.rotation.y = yaw;
        if (t >= 1) rotateAnim.active = false;
      }

      // Движение
      if (isPointerLocked && !rotateAnim.active) {
        const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
        const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

        let dx = 0, dz = 0;
        if (keys['w']) dz -= moveSpeed * delta;
        if (keys['s']) dz += moveSpeed * delta;
        if (keys['a']) dx -= moveSpeed * delta;
        if (keys['d']) dx += moveSpeed * delta;

        let newX = camera.position.x + forward.x * dz + right.x * dx;
        let newZ = camera.position.z + forward.z * dz + right.z * dx;

        const hw = ROOM.w / 2 - MIN_DISTANCE_TO_WALL;
        const hd = ROOM.d / 2 - MIN_DISTANCE_TO_WALL;
        newX = Math.max(-hw, Math.min(hw, newX));
        newZ = Math.max(-hd, Math.min(hd, newZ));

        camera.position.x = newX;
        camera.position.z = newZ;
      }

      renderer.render(scene, camera);
    }

    // === Адаптация под размер окна ===
    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>
