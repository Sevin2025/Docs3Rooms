<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>3D Галерея</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#eee;font-family:Arial,sans-serif}
canvas{display:block}
#ui{position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);padding:8px 12px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.2);}
button{cursor:pointer;font-size:14px;padding:6px 10px;border-radius:6px;border:none;background:#444;color:#fff;}
button:hover{background:#666}
.paintingLabel{pointer-events:none;background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:10;}
#descriptionBox{position:fixed;left:12px;bottom:12px;z-index:30;background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:8px;max-width:40%;display:none;}
#enterHint{position:fixed;left:50%;bottom:40px;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;}
</style>
</head>
<body>
<div id="ui">
  <button id="toggleLabels">Скрыть названия</button>
</div>

<div id="descriptionBox">
  <div id="descTitle" style="font-weight:700;margin-bottom:6px"></div>
  <div id="descText" style="white-space:pre-wrap"></div>
</div>

<div id="enterHint">Кликните по сцене для входа (WASD + мышь)</div>

<script type="module">
import * as THREE from './assets/three/three.module.js';

const ASSETS = './assets/';
const MANIFEST = ASSETS + 'manifest.json';
const DESCRIPTIONS = ASSETS + 'descriptions.json';

let scene, camera, renderer, raycaster;
let paintingPlanes = [];
let labelsVisible = true;
let targetYaw = null;
let targetPos = null;
let moving = false;
let yaw = -Math.PI / 2; // начальное направление — к левой стене (room1)
let doubleClicked = false;

init();

async function init(){
  const [manifest, descriptions] = await Promise.all([
    fetchJSON(MANIFEST),
    fetchJSON(DESCRIPTIONS)
  ]);

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xdddddd);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(0, 1.6, 0); // центр комнаты
  camera.rotation.set(0, yaw, 0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  const amb = new THREE.AmbientLight(0xffffff, 0.8);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(5,10,5);
  scene.add(amb, dir);

  addRoom();
  await addPaintings(manifest, descriptions);

  raycaster = new THREE.Raycaster();

  let isLocked = false;
  renderer.domElement.addEventListener('click', ()=>{
    if(!isLocked){
      isLocked = true;
      document.getElementById("enterHint").style.display="none";
    }
  });

  // Горизонтальный поворот мышью
  document.addEventListener('mousemove', e=>{
    if(!isLocked) return;
    yaw += e.movementX * 0.002;
    yaw = Math.max(-Math.PI/2, Math.min(Math.PI/2, yaw)); // ограничение: только к room1, room2, room3
    camera.rotation.set(0, yaw, 0);
  });

  // WASD движение
  const move = {w:0,s:0,a:0,d:0};
  document.addEventListener('keydown',e=>{
    if(move[e.key.toLowerCase()]!==undefined) move[e.key.toLowerCase()]=1;
  });
  document.addEventListener('keyup',e=>{
    if(move[e.key.toLowerCase()]!==undefined) move[e.key.toLowerCase()]=0;
  });

  function moveLoop(){
    requestAnimationFrame(moveLoop);
    if(!isLocked) return;
    const dir = new THREE.Vector3(move.d-move.a,0,move.s-move.w);
    if(dir.lengthSq()>0){
      dir.normalize();
      const speed = 2.5 * 0.016;
      const sin = Math.sin(yaw), cos = Math.cos(yaw);
      camera.position.x += (dir.x*cos - dir.z*sin)*speed;
      camera.position.z += (dir.x*sin + dir.z*cos)*speed;

      // Ограничение внутри комнаты (не ближе 1 м к стенам)
      camera.position.x = Math.max(-14.9, Math.min(14.9, camera.position.x));
      camera.position.z = Math.max(-14.9, Math.min(14.9, camera.position.z));
    }
  }
  moveLoop();

  // Обработка кликов и двойных кликов
  renderer.domElement.addEventListener('click', onClick);
  renderer.domElement.addEventListener('dblclick', onDblClick);
  window.addEventListener('resize', onResize);

  document.getElementById('toggleLabels').addEventListener('click',()=>{
    labelsVisible = !labelsVisible;
    document.getElementById('toggleLabels').innerText = labelsVisible ? 'Скрыть названия' : 'Показать названия';
    paintingPlanes.forEach(p=>{
      if(p.userData.label) p.userData.label.style.display = labelsVisible ? 'block' : 'none';
    });
  });

  animate();
}

function addRoom(){
  const w = 30, h = 6, d = 30;
  const floorMat = new THREE.MeshStandardMaterial({color:0xD2B48C, side:THREE.DoubleSide}); // светло-коричневый
  const ceilMat  = new THREE.MeshStandardMaterial({color:0xffffff, side:THREE.DoubleSide}); // белый
  const wallMat  = new THREE.MeshStandardMaterial({color:0xE6E6E6, side:THREE.DoubleSide}); // светло-серый
  const backMat  = new THREE.MeshStandardMaterial({color:0x555555, side:THREE.DoubleSide}); // темно-серый

  // Пол
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(w,d), floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  // Потолок
  const ceil = new THREE.Mesh(new THREE.PlaneGeometry(w,d), ceilMat);
  ceil.rotation.x = Math.PI/2;
  ceil.position.y = h;
  scene.add(ceil);

  // Фронтальная стена (room2)
  const front = new THREE.Mesh(new THREE.PlaneGeometry(w,h), wallMat);
  front.position.set(0, h/2, -d/2);
  scene.add(front);

  // Задняя стена (тёмная)
  const back = new THREE.Mesh(new THREE.PlaneGeometry(w,h), backMat);
  back.position.set(0, h/2, d/2);
  back.rotation.y = Math.PI;
  scene.add(back);

  // Левая стена (room1)
  const left = new THREE.Mesh(new THREE.PlaneGeometry(d,h), wallMat);
  left.position.set(-w/2, h/2, 0);
  left.rotation.y = Math.PI/2;
  scene.add(left);

  // Правая стена (room3)
  const right = new THREE.Mesh(new THREE.PlaneGeometry(d,h), wallMat);
  right.position.set(w/2, h/2, 0);
  right.rotation.y = -Math.PI/2;
  scene.add(right);
}

async function addPaintings(manifest, descriptions){
  const loader = new THREE.TextureLoader();
  const sets = [
    { key:'room1', x:-14.9, rotY: -Math.PI/2 }, // левая стена
    { key:'room2', z:-14.9, rotY: 0 },          // фронтальная
    { key:'room3', x:14.9,  rotY: Math.PI/2 }   // правая
  ];

  for(const s of sets){
    const list = manifest[s.key] || [];
    let currentOffset = -10; // отступ от угла, чтобы не в углах
    const gap = 1.5; // расстояние между картинами

    for(let i = 0; i < list.length; i++){
      const file = list[i];
      const meta = descriptions[file] || {};
      const width = meta.width || 1.5;
      const height = meta.height || 1.0;

      const tex = await new Promise((res,rej)=>loader.load(ASSETS+file, res, undefined, rej));
      tex.encoding = THREE.sRGBEncoding;
      tex.anisotropy = 16;

      const mat = new THREE.MeshStandardMaterial({map:tex});
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), mat);

      // Позиционирование по центру с учётом ширины
      currentOffset += width / 2;
      if (s.x !== undefined) mesh.position.x = s.x;
      if (s.z !== undefined) mesh.position.z = s.z;

      if (s.key === 'room1' || s.key === 'room3') {
        mesh.position.z = currentOffset;
      }
      if (s.key === 'room2') {
        mesh.position.x = currentOffset;
      }

      mesh.position.y = 2; // на уровне глаз
      mesh.rotation.y = s.rotY;

      // Рамка
      const frameGeom = new THREE.BoxGeometry(width + 0.2, height + 0.2, 0.1);
      const frameMat = new THREE.MeshStandardMaterial({color:0x6b4226});
      const frame = new THREE.Mesh(frameGeom, frameMat);
      frame.position.copy(mesh.position);
      frame.rotation.copy(mesh.rotation);
      frame.translateZ(-0.08);
      scene.add(frame);

      mesh.translateZ(0.02); // чуть вперёд от рамки
      mesh.userData = {file, meta, room: s.key};

      const label = createLabel(meta.title || file);
      mesh.userData.label = label;

      scene.add(mesh);
      paintingPlanes.push(mesh);

      currentOffset += width / 2 + gap;
    }
  }
}

function createLabel(text){
  const el = document.createElement('div');
  el.className = 'paintingLabel';
  el.innerText = text;
  document.body.appendChild(el);
  return el;
}

// Определяем угол поворота камеры к нужной стене
function getWallYaw(room) {
  if (room === 'room1') return -Math.PI / 2;
  if (room === 'room2') return 0;
  if (room === 'room3') return Math.PI / 2;
  return 0;
}

// Одиночный клик — поворот к картине
function onClick() {
  setTimeout(() => {
    if (doubleClicked) return;
    raycaster.setFromCamera({x:0, y:0}, camera);
    const hits = raycaster.intersectObjects(paintingPlanes, true);
    if (hits.length > 0) {
      const obj = hits[0].object;
      targetYaw = getWallYaw(obj.userData.room);
      showDescription(obj.userData);
    }
  }, 250);
}

// Двойной клик — приближение + поворот
function onDblClick() {
  doubleClicked = true;
  setTimeout(() => doubleClicked = false, 300);

  raycaster.setFromCamera({x:0, y:0}, camera);
  const hits = raycaster.intersectObjects(paintingPlanes, true);
  if (hits.length > 0) {
    const obj = hits[0].object;
    targetYaw = getWallYaw(obj.userData.room);

    const pos = new THREE.Vector3();
    obj.getWorldPosition(pos);
    const quat = new THREE.Quaternion();
    obj.getWorldQuaternion(quat);
    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quat);
    const toPos = pos.clone().add(forward.multiplyScalar(0.9)); // 1 м от стены
    toPos.y = 1.6;
    targetPos = toPos;
    moving = true;

    showDescription(obj.userData);
  }
}

function showDescription(data){
  const box = document.getElementById('descriptionBox');
  document.getElementById('descTitle').innerText = data.meta.title || data.file;
  document.getElementById('descText').innerText = 
    (data.meta.description || 'Описание отсутствует') + 
    (data.meta.author ? `\nАвтор: ${data.meta.author}` : '');
  box.style.display = 'block';
  setTimeout(() => box.style.display = 'none', 10000);
}

function animate(){
  requestAnimationFrame(animate);

  // Плавный поворот к цели
  if (targetYaw !== null) {
    yaw = THREE.MathUtils.lerp(yaw, targetYaw, 0.1);
    camera.rotation.set(0, yaw, 0);
    if (Math.abs(yaw - targetYaw) < 0.01) {
      targetYaw = null;
    }
  }

  // Плавное движение к картине
  if (moving && targetPos) {
    const dir = new THREE.Vector3().subVectors(targetPos, camera.position);
    if (dir.length() > 0.05) {
      camera.position.add(dir.clone().normalize().multiplyScalar(0.05));
    } else {
      camera.position.copy(targetPos);
      moving = false;
      targetPos = null;
    }
  }

  updateLabels();
  renderer.render(scene, camera);
}

function updateLabels(){
  paintingPlanes.forEach(p => {
    if (!p.userData.label || !labelsVisible) return;
    const pos = new THREE.Vector3();
    p.getWorldPosition(pos);
    pos.project(camera);
    const x = (pos.x * 0.5 + 0.5) * innerWidth;
    const y = (-pos.y * 0.5 + 0.5) * innerHeight;
    p.userData.label.style.left = x + 'px';
    p.userData.label.style.top = y + 'px';
  });
}

function onResize(){
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

async function fetchJSON(url){
  const r = await fetch(url);
  if (!r.ok) throw new Error('Ошибка загрузки ' + url);
  return r.json();
}
</script>
</body>
</html>
