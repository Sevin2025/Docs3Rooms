<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>3D Галерея — Docs3Rooms</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #ui {
      position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7);
      padding: 8px; border-radius: 10px; color: white; display: flex; flex-direction: column;
      gap: 6px; z-index: 100; font-size: 12px;
    }
    .row { display: flex; gap: 4px; }
    button {
      width: 40px; height: 40px; font-size: 16px; background: #444; color: white;
      border: none; border-radius: 6px; cursor: pointer; transition: 0.2s;
    }
    button:active { background: #666; transform: scale(0.95); }
    #speedControl { display: flex; align-items: center; gap: 6px; font-size: 11px; }
    #speedSlider { width: 80px; }
    #descriptionBox {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.85); color: white; padding: 10px 16px; border-radius: 8px;
      max-width: 80%; display: none; z-index: 100; text-align: center; font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="descriptionBox">
    <div id="descTitle" style="font-weight:bold; margin-bottom:4px;"></div>
    <div id="descText"></div>
  </div>

  <div id="ui">
    <div class="row">
      <button id="turnLeft">Q</button>
      <button id="turnRight">E</button>
    </div>
    <div class="row">
      <button id="moveForward">W</button>
    </div>
    <div class="row">
      <button id="moveLeft">A</button>
      <button id="moveBackward">S</button>
      <button id="moveRight">D</button>
    </div>
    <div class="row">
      <button id="stepBack" style="background:#c33;">Back</button>
    </div>
    <div id="speedControl">
      <span>Speed:</span>
      <input type="range" id="speedSlider" min="1" max="10" value="5">
      <span id="speedValue">5</span>
    </div>
  </div>

  <script type="module">
    import * as THREE from './assets/three/three.module.js';

    // === Конфигурация комнаты ===
    const ROOM = { w: 15, d: 14, h: 3 };
    const WALL_MARGIN = 0.4;
    const INTERVAL = 0.3;
    const MIN_WALL_DIST = 0.6;
    const MIN_Y = 0.3, MAX_Y = 2.7;
    const MOVE_STEP = 0.12;
    const ROTATE_DURATION = 300;
    const MOVE_SPEED = 3;

    // === Сцена ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, 0);  // Камера на 1.5 м
    camera.rotation.order = 'YXZ';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // === Освещение ===
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 5, 5);
    scene.add(light);

    // === Пол — светло-коричневый ===
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(ROOM.w, ROOM.d),
      new THREE.MeshStandardMaterial({ color: 0xd2b48c })  // светло-коричневый
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // === Потолок — ЧИСТО БЕЛЫЙ (отдельный материал) ===
    const ceiling = new THREE.Mesh(
      new THREE.PlaneGeometry(ROOM.w, ROOM.d),
      new THREE.MeshStandardMaterial({ color: 0xffffff })  // БЕЛЫЙ
    );
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = ROOM.h;
    scene.add(ceiling);

    // === Стены — ВСЕ СВЕТЛО-СЕРЫЕ (отдельный материал) ===
    const wallMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xe0e0e0,  // СВЕТЛО-СЕРЫЙ
      side: THREE.DoubleSide 
    });

    const walls = [
      { pos: new THREE.Vector3(-ROOM.w/2, ROOM.h/2, 0), rot: Math.PI/2, length: ROOM.d },
      { pos: new THREE.Vector3(0, ROOM.h/2, -ROOM.d/2), rot: 0, length: ROOM.w },
      { pos: new THREE.Vector3(ROOM.w/2, ROOM.h/2, 0), rot: -Math.PI/2, length: ROOM.d }
    ];

    walls.forEach(wall => {
      const geo = new THREE.PlaneGeometry(wall.length, ROOM.h);
      const mesh = new THREE.Mesh(geo, wallMaterial);  // Используем только wallMaterial
      mesh.position.copy(wall.pos);
      mesh.rotation.y = wall.rot;
      scene.add(mesh);
    });

    // === Загрузка данных ===
    const manifest = await fetch('./assets/manifest.json').then(r => r.json());
    const descriptions = await fetch('./assets/descriptions.json').then(r => r.json());

    const textureLoader = new THREE.TextureLoader();
    const paintingPlanes = [];

    // === Размещение картин ===
    let currentWallIndex = 0;
    let currentX = 0;

    function placePainting(file, meta) {
      const tex = textureLoader.load(`./assets/${file}`);
      const w = meta.width, h = meta.height;
      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshBasicMaterial({ map: tex });
      const painting = new THREE.Mesh(geo, mat);
      painting.userData = { file, meta };

      while (true) {
        const wall = walls[currentWallIndex];
        const available = wall.length - 2 * WALL_MARGIN;
        if (currentX + w <= available) {
          const localX = -wall.length / 2 + WALL_MARGIN + currentX + w / 2;
          const y = Math.min(Math.max(MIN_Y + h / 2, ROOM.h / 2), MAX_Y - h / 2);
          const isSide = currentWallIndex !== 1; // room2 — фронтальная
          if (isSide) {
            painting.position.set(wall.pos.x, y, localX);
          } else {
            painting.position.set(localX, y, wall.pos.z);
          }
          painting.rotation.y = wall.rot;
          scene.add(painting);
          paintingPlanes.push(painting);
          currentX += w + INTERVAL;
          return;
        } else {
          currentWallIndex = (currentWallIndex + 1) % walls.length;
          currentX = 0;
        }
      }
    }

    // === Загружаем все картины ===
    for (const wallName of ['room1', 'room2', 'room3']) {
      const files = manifest[wallName] || [];
      for (const file of files) {
        const meta = descriptions[file] || { width: 1, height: 1 };
        placePainting(file, meta);
      }
    }

    // === Управление ===
    let yaw = 0, isRotating = false, targetYaw = 0, rotateStartTime = 0;
    let speedMultiplier = 5;
    let approaching = false;
    let targetPos = new THREE.Vector3();

    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    speedSlider.addEventListener('input', () => {
      speedMultiplier = +speedSlider.value;
      speedValue.textContent = speedMultiplier;
    });

    const buttons = {
      turnLeft: document.getElementById('turnLeft'),
      turnRight: document.getElementById('turnRight'),
      moveForward: document.getElementById('moveForward'),
      moveBackward: document.getElementById('moveBackward'),
      moveLeft: document.getElementById('moveLeft'),
      moveRight: document.getElementById('moveRight'),
      stepBack: document.getElementById('stepBack')
    };

    buttons.turnLeft.onclick = () => startRotate(-Math.PI/2);
    buttons.turnRight.onclick = () => startRotate(Math.PI/2);

    ['moveForward', 'moveBackward', 'moveLeft', 'moveRight'].forEach(id => {
      const btn = buttons[id];
      let interval;
      const start = () => { if (!isRotating) interval = setInterval(() => moveCamera(id), 16); };
      const stop = () => clearInterval(interval);
      btn.onmousedown = start;
      btn.onmouseup = stop;
      btn.onmouseleave = stop;
      btn.ontouchstart = e => { e.preventDefault(); start(); };
      btn.ontouchend = stop;
    });

    buttons.stepBack.onclick = () => {
      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      moveTo(camera.position.clone().add(forward.multiplyScalar(-1.5)));
    };

    function startRotate(delta) {
      if (isRotating) return;
      isRotating = true;
      targetYaw = yaw + delta;
      rotateStartTime = performance.now();
      requestAnimationFrame(rotateStep);
    }

    function rotateStep(now) {
      const t = Math.min((now - rotateStartTime) / ROTATE_DURATION, 1);
      const ease = t < 0.5 ? 2*t*t : -1+(4-2*t)*t;
      yaw = yaw + (targetYaw - yaw) * ease;
      camera.rotation.y = yaw;
      if (t < 1) requestAnimationFrame(rotateStep);
      else { yaw = targetYaw; camera.rotation.y = yaw; isRotating = false; }
    }

    function moveCamera(dir) {
      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      let delta = new THREE.Vector3();

      if (dir === 'moveForward') delta = forward.clone().multiplyScalar(MOVE_STEP);
      if (dir === 'moveBackward') delta = forward.clone().multiplyScalar(-MOVE_STEP);
      if (dir === 'moveLeft') delta = right.clone().multiplyScalar(-MOVE_STEP);
      if (dir === 'moveRight') delta = right.clone().multiplyScalar(MOVE_STEP);

      delta.multiplyScalar(speedMultiplier / 5);
      moveTo(camera.position.clone().add(delta));
    }

    function moveTo(target) {
      const hw = ROOM.w/2 - MIN_WALL_DIST;
      const hd = ROOM.d/2 - MIN_WALL_DIST;
      target.x = Math.max(-hw, Math.min(hw, target.x));
      target.z = Math.max(-hd, Math.min(hd, target.z));
      target.y = camera.position.y;
      camera.position.copy(target);
    }

    // === Приближение по удержанию мыши ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('mousedown', e => {
      if (e.button !== 0) return;
      mouse.x = (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = raycaster.intersectObjects(paintingPlanes)[0];
      if (hit) {
        const obj = hit.object;
        const pos = new THREE.Vector3();
        obj.getWorldPosition(pos);
        const normal = new THREE.Vector3();
        obj.getWorldDirection(normal);
        targetPos.copy(pos).add(normal.multiplyScalar(-0.8));
        targetPos.y = camera.position.y;
        const hw = ROOM.w/2 - MIN_WALL_DIST;
        const hd = ROOM.d/2 - MIN_WALL_DIST;
        targetPos.x = Math.max(-hw, Math.min(hw, targetPos.x));
        targetPos.z = Math.max(-hd, Math.min(hd, targetPos.z));
        approaching = true;
        showDescription(obj.userData);
      }
    });

    renderer.domElement.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        mouse.x = (touch.clientX / innerWidth) * 2 - 1;
        mouse.y = -(touch.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hit = raycaster.intersectObjects(paintingPlanes)[0];
        if (hit) {
          const obj = hit.object;
          const pos = new THREE.Vector3();
          obj.getWorldPosition(pos);
          const normal = new THREE.Vector3();
          obj.getWorldDirection(normal);
          targetPos.copy(pos).add(normal.multiplyScalar(-0.8));
          targetPos.y = camera.position.y;
          const hw = ROOM.w/2 - MIN_WALL_DIST;
          const hd = ROOM.d/2 - MIN_WALL_DIST;
          targetPos.x = Math.max(-hw, Math.min(hw, targetPos.x));
          targetPos.z = Math.max(-hd, Math.min(hd, targetPos.z));
          approaching = true;
          showDescription(obj.userData);
        }
      }
    });

    document.addEventListener('mouseup', () => approaching = false);
    document.addEventListener('touchend', () => approaching = false);

    function showDescription(d) {
      const box = document.getElementById('descriptionBox');
      document.getElementById('descTitle').innerText = d.meta?.title || d.file;
      document.getElementById('descText').innerText =
        (d.meta?.description || '') +
        (d.meta?.author ? `\nАвтор: ${d.meta.author}` : '');
      box.style.display = 'block';
      setTimeout(() => box.style.display = 'none', 7000);
    }

    // === Анимация ===
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      camera.rotation.x = 0; // Только горизонтально

      if (approaching) {
        const dir = targetPos.clone().sub(camera.position);
        const dist = dir.length();
        if (dist > 0.05) {
          const step = Math.min(dist, MOVE_SPEED * delta);
          const newPos = camera.position.clone().add(dir.normalize().multiplyScalar(step));
          moveTo(newPos);
        } else {
          approaching = false;
        }
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>
