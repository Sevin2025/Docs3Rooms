<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Виртуальная 3D-галерея — Sergeywieden</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#eee}
#overlayUI{
  position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);
  padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
}
#descriptionBox{
  position:fixed;left:12px;bottom:12px;z-index:30;
  background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
  max-width:40%;display:none;
}
#descTitle{font-weight:700;margin-bottom:6px}
#enterHint{
  position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
  background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
}
.paintingLabel{
  pointer-events:none;
  background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
  position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:19;
}
canvas{display:block}
button,select,input{font-size:13px}
</style>
</head>
<body>
<div id="overlayUI">
  <div><strong>3D-галерея</strong></div>
  <div style="font-size:13px;margin-top:6px">
    Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
    Управление: WASD + мышь. Клик — описание.
  </div>
  <div style="margin-top:8px">
    <label><input id="showLabels" type="checkbox" checked> Подписи</label>
  </div>
  <div style="margin-top:6px">
    <button id="resetPos">Сброс позиции</button>
  </div>
  <div style="margin-top:6px">
    <label>Режим:
      <select id="moveMode">
        <option value="fp">1-е лицо</option>
        <option value="orbit">Orbit</option>
      </select>
    </label>
  </div>
  <div style="margin-top:6px">
    <button id="toRoom1">Зал 1</button>
    <button id="toRoom2">Зал 2</button>
    <button id="toRoom3">Зал 3</button>
  </div>
  <div style="margin-top:6px;font-size:12px;color:#666">
    Загрузка: <span id="loadStatus">0%</span>
  </div>
</div>

<div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
<div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выход.</div>

<script type="module">
import * as THREE from './assets/three/three.module.js';
import { PointerLockControls } from './assets/three/PointerLockControls.js';
import { OrbitControls } from './assets/three/OrbitControls.js';

const ASSETS_BASE = './assets/';
const MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
const DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

let scene,camera,renderer,controlsFP,controlsOrbit,currentControls;
let raycaster=new THREE.Raycaster(),mouse=new THREE.Vector2();
let paintingsGroup=new THREE.Group();
let paintingPlanes=[];
let INTERSECTED=null;
const roomCount=3;
const roomSize={w:10,h:4,d:10}; // квадратные залы
let loadTotal=0,loadDone=0;
const moveSpeed=3.0;

init();

async function init(){
  setLoadStatus('Загрузка...');
  try{
    const [manifest,descriptions]=await Promise.all([
      fetchJSON(MANIFEST_PATH),
      fetchJSON(DESCRIPTIONS_PATH)
    ]);

    scene=new THREE.Scene();
    scene.background=new THREE.Color(0xdddddd);

    camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,400);
    camera.position.set(0,1.6,0);

    renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    renderer.outputEncoding=THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const amb=new THREE.AmbientLight(0xffffff,0.7);
    const dir=new THREE.DirectionalLight(0xffffff,0.6);
    dir.position.set(5,10,5);
    scene.add(amb,dir);

    // создаём комнаты
    const roomsGroup=new THREE.Group();
    const gap=2;
    for(let i=0;i<roomCount;i++){
      const room=new THREE.Group();
      const xOffset=i*(roomSize.w+gap);
      room.position.set(xOffset,0,0);
      room.name=`room${i+1}`;
      addRoomGeometry(room);
      roomsGroup.add(room);
    }
    roomsGroup.position.x=-((roomCount-1)*(roomSize.w+gap))/2;
    scene.add(roomsGroup);

    await placePaintings(manifest,descriptions);
    scene.add(paintingsGroup);

    controlsFP=new PointerLockControls(camera,renderer.domElement);
    controlsOrbit=new OrbitControls(camera,renderer.domElement);
    controlsOrbit.enabled=false;
    currentControls=controlsFP;

    renderer.domElement.addEventListener('click',()=>{
      if(document.getElementById('moveMode').value==='fp'){
        controlsFP.lock();
        document.getElementById('enterHint').style.display='none';
      }
    });

    window.addEventListener('resize',onResize);
    document.addEventListener('mousemove',onMouseMove);
    document.addEventListener('click',onClick);
    document.getElementById('showLabels').addEventListener('change',ev=>toggleLabels(ev.target.checked));
    document.getElementById('resetPos').addEventListener('click',()=>{camera.position.set(0,1.6,0);camera.rotation.set(0,0,0);});
    document.getElementById('moveMode').addEventListener('change',ev=>{
      ev.target.value==='orbit'?switchOrbit():switchFP();
    });
    document.getElementById('toRoom1').addEventListener('click',()=>moveToRoom(1));
    document.getElementById('toRoom2').addEventListener('click',()=>moveToRoom(2));
    document.getElementById('toRoom3').addEventListener('click',()=>moveToRoom(3));

    setupWASD();
    animate();
    setLoadStatus('Готово');
  }catch(e){
    console.error(e);
    setLoadStatus('Ошибка: '+e.message);
  }
}

async function fetchJSON(url){
  const r=await fetch(url);
  if(!r.ok) throw new Error('Не удалось загрузить '+url);
  return r.json();
}
function setLoadStatus(t){const el=document.getElementById('loadStatus');if(el)el.innerText=t;}

function addRoomGeometry(room){
  const floorColor=0x8B4513; // коричневый пол
  const wallColor=0xE6E6E6;
  const ceilingColor=0xFFFFFF;

  const floorMat=new THREE.MeshStandardMaterial({color:floorColor,side:THREE.DoubleSide});
  const floor=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.d),floorMat);
  floor.rotation.x=-Math.PI/2; floor.position.y=0; room.add(floor);

  const ceilingMat=new THREE.MeshStandardMaterial({color:ceilingColor,side:THREE.DoubleSide});
  const ceiling=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.d),ceilingMat);
  ceiling.rotation.x=Math.PI/2; ceiling.position.y=roomSize.h; room.add(ceiling);

  const wallMat=new THREE.MeshStandardMaterial({color:wallColor,side:THREE.DoubleSide});
  const back=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.h),wallMat);
  back.position.set(0,roomSize.h/2,-roomSize.d/2);
  const front=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.h),wallMat);
  front.position.set(0,roomSize.h/2,roomSize.d/2); front.rotation.y=Math.PI;
  const left=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d,roomSize.h),wallMat);
  left.position.set(-roomSize.w/2,roomSize.h/2,0); left.rotation.y=Math.PI/2;
  const right=new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d,roomSize.h),wallMat);
  right.position.set(roomSize.w/2,roomSize.h/2,0); right.rotation.y=-Math.PI/2;
  room.add(back,front,left,right);
}

async function placePaintings(manifest,descriptions){
  const loader=new THREE.TextureLoader();
  const keys=['room1','room2','room3'];
  loadTotal=0;loadDone=0;keys.forEach(k=>{if(Array.isArray(manifest[k]))loadTotal+=manifest[k].length;});
  if(loadTotal===0)loadTotal=1;

  for(let r=0;r<3;r++){
    const roomKey=keys[r];
    const list=manifest[roomKey]||[];
    for(let i=0;i<list.length;i++){
      const fname=list[i];
      const url=ASSETS_BASE+fname;
      try{
        const tex=await new Promise((res,rej)=>loader.load(url,res,undefined,rej));
        tex.encoding=THREE.sRGBEncoding;
        const aspect=tex.image.width/tex.image.height;
        const height=1.0,width=height*aspect;
        const mat=new THREE.MeshStandardMaterial({map:tex});
        const plane=new THREE.Mesh(new THREE.PlaneGeometry(width,height),mat);

        const perWall=Math.ceil(list.length/4);
        const wallIndex=Math.floor(i/perWall)%4;
        const indexOnWall=i%perWall;
        const margin=0.5;
        const usableLen=roomSize.w-2*margin;
        const along=-usableLen/2+(indexOnWall+0.5)*(usableLen/Math.max(1,perWall));
        const gap=2;
        const roomCenterX=r*(roomSize.w+gap)-((3-1)*(roomSize.w+gap))/2;
        let px=roomCenterX,pz=0,rotY=0,py=1.6;
        if(wallIndex===0){px+=along;pz=-roomSize.d/2+0.01;rotY=0;}
        else if(wallIndex===1){px+=along;pz=roomSize.d/2-0.01;rotY=Math.PI;}
        else if(wallIndex===2){px=roomCenterX-roomSize.w/2+0.01;pz=along;rotY=Math.PI/2;}
        else{px=roomCenterX+roomSize.w/2-0.01;pz=along;rotY=-Math.PI/2;}
        plane.position.set(px,py,pz); plane.rotation.y=rotY;
        plane.userData={file:fname,room:r+1,meta:descriptions[fname]||{}};

        const frameThickness=0.05,frameDepth=0.02;
        const frameGeom=new THREE.BoxGeometry(width+frameThickness,height+frameThickness,frameDepth);
        const frameMat=new THREE.MeshStandardMaterial({color:0x6b4226});
        const frame=new THREE.Mesh(frameGeom,frameMat);
        frame.position.copy(plane.position);
        frame.rotation.copy(plane.rotation);
        frame.translateZ(-frameDepth/2-0.005);

        const label=createLabel(fname);
        plane.userData.labelEl=label;

        paintingsGroup.add(frame);paintingsGroup.add(plane);
        paintingPlanes.push({mesh:plane,id:fname,meta:plane.userData.meta});
      }catch(e){console.warn('Ошибка загрузки',url,e);}
      finally{loadDone++;setLoadStatus(Math.round(loadDone/loadTotal*100)+'%');}
    }
  }
}

function createLabel(text){
  const el=document.createElement('div');
  el.className='paintingLabel'; el.innerText=text;
  el.style.display=document.getElementById('showLabels').checked?'block':'none';
  document.body.appendChild(el); return el;
}
function toggleLabels(show){paintingPlanes.forEach(p=>{if(p.mesh.userData.labelEl)p.mesh.userData.labelEl.style.display=show?'block':'none';});}
function onMouseMove(e){mouse.x=(e.clientX/innerWidth)*2-1;mouse.y=-(e.clientY/innerHeight)*2+1;}
function onClick(){
  raycaster.setFromCamera(mouse,camera);
  const inter=raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.geometry),true);
  if(inter.length>0)showDescription(inter[0].object.userData);
}
function showDescription(d){
  if(!d)return;
  const box=document.getElementById('descriptionBox');
  document.getElementById('descTitle').innerText=d.meta?.title||d.file||'Картина';
  const author=d.meta?.author?('\nАвтор: '+d.meta.author):'';
  document.getElementById('descText').innerText=(d.meta?.description||'Описание отсутствует')+author;
  box.style.display='block'; setTimeout(()=>box.style.display='none',10000);
}
function switchOrbit(){controlsFP.unlock&&controlsFP.unlock();controlsOrbit.enabled=true;currentControls=controlsOrbit;}
function switchFP(){controlsOrbit.enabled=false;currentControls=controlsFP;}

function moveToRoom(n){
  const gap=2;
  const offset=(n-1)*(roomSize.w+gap)-((roomCount-1)*(roomSize.w+gap))/2;
  const targetPos=new THREE.Vector3(offset,1.6,0);
  const targetQuat=new THREE.Quaternion();
  targetQuat.setFromEuler(new THREE.Euler(0,0,0));
  const startPos=camera.position.clone();
  const startQuat=camera.quaternion.clone();
  let t=0;
  const duration=1.5;
  function animateMove(){
    t+=0.016/duration;
    if(t>=1)t=1;
    camera.position.lerpVectors(startPos,targetPos,t);
    THREE.Quaternion.slerp(startQuat,targetQuat,camera.quaternion,t);
    if(t<1)requestAnimationFrame(animateMove);
  }
  animateMove();
}

function animate(){
  requestAnimationFrame(animate);
  if(currentControls===controlsOrbit)controlsOrbit.update();

  raycaster.setFromCamera(mouse,camera);
  const inter=raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.material),true);
  if(inter.length>0){
    if(INTERSECTED!==inter[0].object){
      if(INTERSECTED?.material?.emissive)INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED=inter[0].object;
      if(INTERSECTED?.material?.emissive)INTERSECTED.material.emissive.setHex(0x222222);
    }
  }else{
    if(INTERSECTED?.material?.emissive)INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED=null;
  }

  paintingPlanes.forEach(p=>{if(p.mesh.userData.labelEl)updateLabelPosition(p.mesh);});
  renderer.render(scene,camera);
}

function updateLabelPosition(mesh){
  const el=mesh.userData.labelEl;if(!el)return;
  const pos=new THREE.Vector3(); mesh.getWorldPosition(pos); pos.project(camera);
  const x=(pos.x*0.5+0.5)*innerWidth; const y=(-pos.y*0.5+0.5)*innerHeight;
  el.style.left=x+'px'; el.style.top=y+'px';
}
function onResize(){camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);}
function setupWASD(){
  const move={f:false,b:false,l:false,r:false};
  const dir=new THREE.Vector3();
  document.addEventListener('keydown',e=>{
    if(e.code==='KeyW')move.f=true;
    if(e.code==='KeyS')move.b=true;
    if(e.code==='KeyA')move.l=true;
    if(e.code==='KeyD')move.r=true;
  });
  document.addEventListener('keyup',e=>{
    if(e.code==='KeyW')move.f=false;
    if(e.code==='KeyS')move.b=false;
    if(e.code==='KeyA')move.l=false;
    if(e.code==='KeyD')move.r=false;
  });
  (function tick(){
    requestAnimationFrame(tick);
    if(currentControls===controlsFP && controlsFP.isLocked){
      dir.z=Number(move.f)-Number(move.b);
      dir.x=Number(move.r)-Number(move.l);
      dir.normalize();
      if(dir.lengthSq()>0){
        const moveVec=new THREE.Vector3(dir.x,0,dir.z).multiplyScalar(moveSpeed*0.016);
        controlsFP.moveRight(moveVec.x);
        controlsFP.moveForward(moveVec.z);
      }
    }
  })();
}
</script>
</body>
</html>
