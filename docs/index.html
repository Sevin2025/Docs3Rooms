<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Виртуальная 3D-галерея — Sergeywieden</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#eee}
#overlayUI{
  position:fixed;right:12px;top:12px;z-index:60;background:rgba(255,255,255,0.95);
  padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:340px;
}
#descriptionBox{
  position:fixed;left:12px;bottom:12px;z-index:70;
  background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
  max-width:40%;display:none;
}
#descTitle{font-weight:700;margin-bottom:6px}
#enterHint{
  position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:65;
  background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
}
.paintingLabel{
  pointer-events:none;
  background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
  position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:59;
}
canvas{display:block}
button, select, input{font-size:13px}
#roomButtons{margin-top:8px;display:flex;gap:6px;flex-wrap:wrap}
.door{opacity:0.9}
</style>
</head>
<body>

<div id="overlayUI">
  <div><strong>3D-галерея</strong></div>
  <div style="font-size:13px;margin-top:6px">
    Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
    Управление: WASD + мышь. Клик на картину — приближение/описание.
  </div>
  <div id="roomButtons">
    <button data-room="1">В комнату 1</button>
    <button data-room="2">В комнату 2</button>
    <button data-room="3">В комнату 3</button>
  </div>
  <div style="margin-top:8px">
    <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
  </div>
  <div style="margin-top:6px">
    <button id="resetPos">Сброс позиции</button>
  </div>
  <div style="margin-top:6px">
    <label>Режим:
      <select id="moveMode">
        <option value="fp">1st-person</option>
        <option value="orbit">Orbit</option>
      </select>
    </label>
  </div>
  <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
</div>

<div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
<div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выйти.</div>

<script type="module">
import * as THREE from './assets/three/three.module.js';
import { PointerLockControls } from './assets/three/PointerLockControls.js';
import { OrbitControls } from './assets/three/OrbitControls.js';

const ASSETS_BASE = './assets/';
const MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
const DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let paintingsGroup = new THREE.Group();
let paintingPlanes = []; // {mesh, id, meta}
let frameMeshes = []; // doors + frames
let INTERSECTED = null;

const roomCount = 3;
// room 1 will be narrow and long
const roomSizeByIndex = [
  { w:6, h:4, d:18 }, // room1: narrow & long
  { w:12, h:4, d:12 },
  { w:12, h:4, d:12 }
];

let loadTotal = 0, loadDone = 0;

// smooth movement/rotation state
let cameraMove = null; // {from:Vector3,to:Vector3,quatFrom:Q,quatTo:Q,t:0..1,duration}
const MOVE_DURATION = 0.8; // sec

// approach target for paintings (smoothly move camera to target + slerp look)
let approach = null; // {toPos:Vector3,lookAt:Vector3,t:0..1,duration}

init();

async function init(){
  setLoadStatus('Загрузка файлов...');
  try{
    const [manifest, descriptions] = await Promise.all([fetchJSON(MANIFEST_PATH), fetchJSON(DESCRIPTIONS_PATH)]);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);

    // initial camera at room 2 center (so user sees middle room by default)
    const gap = 2;
    const roomCenters = computeRoomCenters(roomSizeByIndex, gap);
    camera.position.copy(roomCenters[1].clone().add(new THREE.Vector3(0,1.6,0)));

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.8);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,5);
    scene.add(amb, dir);

    // build rooms
    const roomsGroup = new THREE.Group();
    for(let i=0;i<roomCount;i++){
      const dims = roomSizeByIndex[i];
      const room = new THREE.Group();
      const xOffset = i * (dims.w + gap);
      room.position.set(xOffset, 0, 0);
      room.name = `room${i+1}`;
      addRoomGeometry(room, dims);
      roomsGroup.add(room);
    }
    // center the whole gallery
    const totalWidth = roomSizeByIndex.reduce((s,d)=>s+d.w,0) + gap*(roomCount-1);
    roomsGroup.position.x = - (totalWidth/2) + roomSizeByIndex[0].w/2;
    scene.add(roomsGroup);

    // place doors visually between rooms (and clickable)
    addDoorsBetweenRooms(roomSizeByIndex, gap, roomsGroup.position.x);

    // place paintings (room1 will have placeholders if manifest empty)
    await placePaintings(manifest, descriptions);
    scene.add(paintingsGroup);

    // controls
    controlsFP = new PointerLockControls(camera, renderer.domElement);
    controlsOrbit = new OrbitControls(camera, renderer.domElement);
    controlsOrbit.enableDamping = true;
    controlsOrbit.enabled = false;
    currentControls = controlsFP;

    // pointer lock on canvas click (FP mode)
    renderer.domElement.addEventListener('click', ()=>{
      if(document.getElementById('moveMode').value==='fp'){
        controlsFP.lock();
        document.getElementById('enterHint').style.display='none';
      }
    });

    window.addEventListener('resize', onResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('click', onClick);
    document.getElementById('showLabels').addEventListener('change', ev=>toggleLabels(ev.target.checked));
    document.getElementById('resetPos').addEventListener('click', ()=>{ camera.position.copy(roomCenters[1].clone().add(new THREE.Vector3(0,1.6,0))); camera.quaternion.set(0,0,0,1); });
    document.getElementById('moveMode').addEventListener('change', ev=>{ ev.target.value==='orbit'?switchOrbit():switchFP(); });

    // room buttons
    document.querySelectorAll('#roomButtons button').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        const rid = Number(btn.getAttribute('data-room')) - 1;
        if(isNaN(rid) || rid<0 || rid>=roomCount) return;
        moveToRoom(rid);
      });
    });

    setupWASD();
    animate();
    setLoadStatus('Готово');
  }catch(err){
    console.error(err);
    setLoadStatus('Ошибка: '+(err.message||err));
  }
}

function computeRoomCenters(sizes, gap){
  const centers = [];
  let x=0;
  for(let i=0;i<sizes.length;i++){
    const w = sizes[i].w;
    centers.push(new THREE.Vector3(x + w/2, 0, 0));
    x += w + gap;
  }
  // now shift so center around 0: compute full width and subtract half
  const totalWidth = sizes.reduce((s,d)=>s+d.w,0) + gap*(sizes.length-1);
  const shift = - (totalWidth/2) + sizes[0].w/2;
  centers.forEach(c=>c.x += shift);
  return centers;
}

async function fetchJSON(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error('Не удалось загрузить '+url);
  return r.json();
}

function setLoadStatus(text){ const el=document.getElementById('loadStatus'); if(el) el.innerText=text; }

function addRoomGeometry(room, dims){
  const floorColor = 0xD2B48C, wallColor = 0xE6E6E6, ceilingColor = 0xFFFFFF;

  const floorMat = new THREE.MeshStandardMaterial({ color: floorColor, side: THREE.DoubleSide });
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(dims.w, dims.d), floorMat);
  floor.rotation.x = -Math.PI/2;
  floor.position.y = 0;
  room.add(floor);

  const ceilingMat = new THREE.MeshStandardMaterial({ color: ceilingColor, side: THREE.DoubleSide });
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(dims.w, dims.d), ceilingMat);
  ceiling.rotation.x = Math.PI/2;
  ceiling.position.y = dims.h;
  room.add(ceiling);

  const wallMat = new THREE.MeshStandardMaterial({ color: wallColor, side: THREE.DoubleSide });
  const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(dims.w, dims.h), wallMat);
  wallBack.position.set(0, dims.h/2, -dims.d/2);

  const wallFront = new THREE.Mesh(new THREE.PlaneGeometry(dims.w, dims.h), wallMat);
  wallFront.position.set(0, dims.h/2, dims.d/2);
  wallFront.rotation.y = Math.PI;

  const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(dims.d, dims.h), wallMat);
  wallLeft.position.set(-dims.w/2, dims.h/2, 0);
  wallLeft.rotation.y = Math.PI/2;

  const wallRight = new THREE.Mesh(new THREE.PlaneGeometry(dims.d, dims.h), wallMat);
  wallRight.position.set(dims.w/2, dims.h/2, 0);
  wallRight.rotation.y = -Math.PI/2;

  room.add(wallBack, wallFront, wallLeft, wallRight);
}

function addDoorsBetweenRooms(sizes, gap, offsetX){
  // Create simple door meshes at midpoints between rooms; clickable -> moveToRoom
  let xAcc = offsetX;
  for(let i=0;i<sizes.length-1;i++){
    const w1 = sizes[i].w;
    const midX = xAcc + w1 + gap/2;
    const doorHeight = 2.2, doorWidth = 1.6;
    // door plane facing +Z (we'll place vertical plane)
    const doorGeom = new THREE.PlaneGeometry(doorWidth, doorHeight);
    const doorMat = new THREE.MeshStandardMaterial({color:0x444444, side:THREE.DoubleSide});
    const door = new THREE.Mesh(doorGeom, doorMat);
    door.position.set(midX, doorHeight/2, 0);
    door.rotation.y = Math.PI/2;
    door.name = `door_${i+1}_${i+2}`;
    door.userData = {type:'door',from:i,to:i+1};
    door.renderOrder = 10;
    scene && scene.add ? scene.add(door) : paintingsGroup.add(door);
    frameMeshes.push(door);

    // make smaller doorway on other side as well (visual)
    const door2 = door.clone();
    door2.position.set(midX, doorHeight/2, 0);
    door2.rotation.y = -Math.PI/2;
    door2.userData = {type:'door',from:i+1,to:i};
    frameMeshes.push(door2);
    if(scene) scene.add(door2);

    xAcc += w1 + gap;
  }
}

async function placePaintings(manifest, descriptions){
  const loader = new THREE.TextureLoader();
  const keys = ['room1','room2','room3'];
  loadTotal = 0; loadDone = 0; keys.forEach(k=>{ if(Array.isArray(manifest[k])) loadTotal+=manifest[k].length; });
  if(loadTotal===0) loadTotal=1;

  const gap = 2;
  const roomCenters = computeRoomCenters(roomSizeByIndex, gap);

  for(let r=0;r<3;r++){
    const roomKey = keys[r];
    const list = manifest[roomKey] || [];

    // If room 1 empty, we create plain brown placeholders (no descriptions)
    const isRoom1 = (r===0);
    const dims = roomSizeByIndex[r];
    const perWall = Math.max(1, Math.ceil(list.length/4));

    // compute usable placement per wall
    for(let i=0;i<(isRoom1 && list.length===0 ? 4 : list.length); i++){
      const isPlaceholder = isRoom1 && list.length===0;
      const fname = isPlaceholder ? `placeholder_${r+1}_${i+1}` : list[i % Math.max(1, list.length)];
      try{
        let width, height, mat, plane;
        if(isPlaceholder){
          // brown framed rectangle
          height = 1.2;
          width = 0.9;
          mat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b }); // brown
          plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), mat);
        } else {
          const url = ASSETS_BASE + fname;
          const tex = await new Promise((res,rej)=>loader.load(url,res,undefined,rej));
          tex.encoding = THREE.sRGBEncoding;
          const aspect = tex.image.width/tex.image.height;
          height = 1.0; width = Math.max(0.3, height*aspect);
          mat = new THREE.MeshStandardMaterial({ map: tex });
          plane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), mat);
        }

        // position on walls
        const indexInList = isPlaceholder ? i : i;
        const wallIndex = Math.floor(indexInList / perWall) % 4;
        const indexOnWall = indexInList % perWall;
        const margin = 0.5;
        const usableLen = dims.w - 2*margin;
        let along = -usableLen/2 + (indexOnWall + 0.5) * (usableLen / Math.max(1, perWall));

        // compute absolute room center X:
        const roomCenterX = roomCenters[r].x;
        let px = roomCenterX, pz = 0, rotY = 0, py = 1.6;
        if(wallIndex === 0){ px += along; pz = -dims.d/2 + 0.01; rotY = 0; }
        else if(wallIndex === 1){ px += along; pz = dims.d/2 - 0.01; rotY = Math.PI; }
        else if(wallIndex === 2){ px = roomCenterX - dims.w/2 + 0.01; pz = along; rotY = Math.PI/2; }
        else { px = roomCenterX + dims.w/2 - 0.01; pz = along; rotY = -Math.PI/2; }

        plane.position.set(px, py, pz);
        plane.rotation.y = rotY;
        plane.userData = { file: isPlaceholder ? null : fname, room: r+1, meta: (isPlaceholder ? {} : (descriptions[fname] || {})) };

        // frame
        const frameThickness = 0.05, frameDepth = 0.02;
        const frameGeom = new THREE.BoxGeometry(width + frameThickness, height + frameThickness, frameDepth);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0x6b4226 });
        const frame = new THREE.Mesh(frameGeom, frameMat);
        frame.position.copy(plane.position);
        frame.rotation.copy(plane.rotation);
        frame.translateZ(-frameDepth/2 - 0.005);
        frame.userData = plane.userData; // copy userData so clicks on frame work

        // special: room1 placeholders have no descriptions
        if(isPlaceholder) frame.userData.meta = {};

        const label = createLabel(isPlaceholder ? '' : (fname));
        plane.userData.labelEl = label;
        frame.userData.labelEl = label;

        paintingsGroup.add(frame);
        paintingsGroup.add(plane);
        paintingPlanes.push({ mesh: plane, id: fname, meta: plane.userData.meta });
        frameMeshes.push(frame);
      }catch(err){
        console.warn('Загрузка не удалась', err);
      }finally{
        loadDone++; setLoadStatus(Math.round(loadDone/loadTotal*100)+'%');
      }
    }
  }
}

function createLabel(text){
  const el = document.createElement('div'); el.className='paintingLabel'; el.innerText = text || '';
  el.style.display = document.getElementById('showLabels').checked ? 'block' : 'none';
  document.body.appendChild(el);
  return el;
}

function toggleLabels(show){
  paintingPlanes.forEach(p => { if(p.mesh.userData.labelEl) p.mesh.userData.labelEl.style.display = show ? 'block' : 'none'; });
}

function onMouseMove(e){
  // pointer lock mode: do not update mouse coords (we use center)
  if(document.pointerLockElement === renderer.domElement) return;
  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
}

function onClick(e){
  // if clicked on door/frame via raycast
  if(document.pointerLockElement === renderer.domElement){
    mouse.set(0,0); // center
  }
  raycaster.setFromCamera(mouse, camera);

  // prioritize doors (frameMeshes contain doors and frames)
  const pickedDoors = raycaster.intersectObjects(frameMeshes, true);
  if(pickedDoors.length > 0){
    const first = pickedDoors[0].object;
    if(first.userData && first.userData.type === 'door'){
      // move between rooms smoothly
      const targetRoom = first.userData.to;
      moveToRoom(targetRoom);
      return;
    } else if(first.userData && (first.userData.file !== undefined || first.userData.meta !== undefined)){
      // clicked a frame -> treat as painting click
      handlePaintingClick(first);
      return;
    }
  }

  // otherwise intersect planes (paintingsGroup)
  const targets = paintingPlanes.map(p => p.mesh);
  const intersects = raycaster.intersectObjects(targets, true);
  if(intersects.length > 0){
    handlePaintingClick(intersects[0].object);
  } else {
    // click on empty space: cancel approach
    approach = null;
  }
}

function handlePaintingClick(obj){
  if(!obj || !obj.userData) return;
  const ud = obj.userData;
  // if no file/meta (placeholder), do not show description
  if(ud && ud.meta && Object.keys(ud.meta).length > 0){
    showDescription(ud);
  }
  // compute a target position a little in front of the painting, at eye level
  const worldPos = new THREE.Vector3();
  obj.getWorldPosition(worldPos);
  const worldQuat = new THREE.Quaternion();
  obj.getWorldQuaternion(worldQuat);
  // painting forward is +Z of plane in local; compute world forward:
  const forward = new THREE.Vector3(0,0,1).applyQuaternion(worldQuat);
  // position camera in front of painting at distance
  const distance = 1.0; // distance from painting plane
  const targetPos = worldPos.clone().add(forward.clone().multiplyScalar(-distance));
  targetPos.y = 1.6; // eye level fixed
  const lookAt = worldPos.clone();
  lookAt.y = 1.6; // horizontal look
  // start approach (smooth move + slerp look)
  startApproach(targetPos, lookAt, 0.9);
}

function showDescription(userData){
  if(!userData) return;
  const box = document.getElementById('descriptionBox');
  document.getElementById('descTitle').innerText = userData.meta?.title || userData.file || 'Картина';
  const author = userData.meta?.author ? ('\nАвтор: '+userData.meta.author) : '';
  document.getElementById('descText').innerText = (userData.meta?.description || 'Описание отсутствует') + author;
  box.style.display = 'block';
  setTimeout(()=>box.style.display='none', 14000);
}

function switchOrbit(){ controlsFP.unlock && controlsFP.unlock(); controlsOrbit.enabled=true; currentControls=controlsOrbit; }
function switchFP(){ controlsOrbit.enabled=false; currentControls=controlsFP; }

function moveToRoom(roomIndex){
  // roomIndex is 0-based or 1-based? adapt:
  const rid = (roomIndex>=1) ? roomIndex-1 : roomIndex;
  if(rid < 0 || rid >= roomSizeByIndex.length) return;
  const gap = 2;
  const centers = computeRoomCenters(roomSizeByIndex, gap);
  const targetCenter = centers[rid].clone().add(new THREE.Vector3(0,1.6,0));
  startCameraMove(targetCenter, 0.9);
}

function startCameraMove(targetPos, lookAtDistance=1.0){
  // set cameraMove: position and quaternion
  const fromPos = camera.position.clone();
  // compute lookAt quaternion so camera looks horizontally to center of room
  const lookAt = new THREE.Vector3(targetPos.x, 1.6, 0); // aim toward center z=0
  // safer: aim slightly forward from target (so camera faces toward centerline)
  const toQuat = computeLookQuaternion(camera.position, lookAt);
  const fromQuat = camera.quaternion.clone();
  cameraMove = { from: fromPos, to: targetPos.clone(), quatFrom: fromQuat, quatTo: toQuat, t: 0, duration: MOVE_DURATION };
}

function startApproach(toPos, lookAt, duration=0.9){
  approach = { toPos: toPos.clone(), lookAt: lookAt.clone(), t:0, duration: duration };
}

function computeLookQuaternion(fromPos, lookAt){
  // compute quaternion that rotates camera so its forward looks at lookAt, keeping up vector (0,1,0),
  // but ensure camera's up is (0,1,0) and no pitch downward/upward beyond horizontal? we keep horizontal by setting target.y = camera.y where needed.
  const m = new THREE.Matrix4();
  const cam = new THREE.Object3D();
  cam.position.copy(fromPos);
  // ensure lookAt has same y as camera to keep strictly horizontal
  const look = lookAt.clone();
  look.y = fromPos.y;
  cam.lookAt(look);
  m.lookAt(fromPos, look, cam.up);
  const q = new THREE.Quaternion();
  q.setFromRotationMatrix(m);
  return q;
}

function animate(){
  requestAnimationFrame(animate);

  // update controls when orbit enabled
  if(currentControls === controlsOrbit) controlsOrbit.update();

  // animate cameraMove (teleport between rooms) with slerp
  if(cameraMove){
    cameraMove.t += (1/60) / cameraMove.duration;
    const t = Math.min(1, cameraMove.t);
    // smoothstep easing
    const tt = t * t * (3 - 2 * t);
    camera.position.lerpVectors(cameraMove.from, cameraMove.to, tt);
    THREE.Quaternion.slerp(cameraMove.quatFrom, cameraMove.quatTo, camera.quaternion, tt);
    if(t >= 1) cameraMove = null;
  }

  // approach animation (to painting)
  if(approach){
    approach.t += (1/60)/approach.duration;
    const t = Math.min(1, approach.t);
    const tt = t * t * (3 - 2 * t); // smoothstep
    camera.position.lerp( camera.position.clone(), approach.toPos, tt ); // move towards toPos
    // smooth look: compute target quaternion to look at approach.lookAt horizontally
    const qTarget = computeLookQuaternion(camera.position, approach.lookAt);
    THREE.Quaternion.slerp(camera.quaternion, qTarget, camera.quaternion, 0.12);
    if(t >= 1) { approach = null; }
  }

  // raycast (center if pointer locked)
  if(document.pointerLockElement === renderer.domElement){
    mouse.set(0,0);
  }
  raycaster.setFromCamera(mouse, camera);

  // highlight paintings (only actual painting planes)
  const targets = paintingPlanes.map(p => p.mesh);
  const intersects = raycaster.intersectObjects(targets, true);
  if(intersects.length>0){
    if(INTERSECTED !== intersects[0].object){
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED = intersects[0].object;
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x222222);
    }
  } else {
    if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED = null;
  }

  // update labels
  paintingPlanes.forEach(p => { if(p.mesh.userData.labelEl && p.mesh.visible) updateLabelPosition(p.mesh); });

  renderer.render(scene, camera);
}

function updateLabelPosition(mesh){
  const el = mesh.userData.labelEl;
  if(!el) return;
  const pos = new THREE.Vector3();
  mesh.getWorldPosition(pos);
  pos.project(camera);
  const x = (pos.x*0.5+0.5)*innerWidth;
  const y = (-pos.y*0.5+0.5)*innerHeight;
  el.style.left = x + 'px'; el.style.top = y + 'px';
}

function onResize(){ camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

function setupWASD(){
  const move = { forward:false, back:false, left:false, right:false };
  const dir = new THREE.Vector3();
  const speed = 3.0;

  document.addEventListener('keydown', e=>{
    if(e.code==='KeyW') move.forward=true;
    if(e.code==='KeyS') move.back=true;
    if(e.code==='KeyA') move.left=true;
    if(e.code==='KeyD') move.right=true;
    if(e.code==='Escape'){ approach = null; cameraMove = null; controlsFP.unlock && controlsFP.unlock(); }
  });
  document.addEventListener('keyup', e=>{
    if(e.code==='KeyW') move.forward=false;
    if(e.code==='KeyS') move.back=false;
    if(e.code==='KeyA') move.left=false;
    if(e.code==='KeyD') move.right=false;
  });

  (function tick(){
    requestAnimationFrame(tick);
    if(currentControls === controlsFP && controlsFP.isLocked === true){
      const delta = 0.016;
      dir.z = Number(move.forward) - Number(move.back);
      dir.x = Number(move.right) - Number(move.left);
      if(dir.lengthSq() > 0){
        dir.normalize();
        // move relative to camera orientation provided by PointerLockControls
        const moveVec = new THREE.Vector3(dir.x, 0, dir.z).multiplyScalar(speed*delta);
        controlsFP.moveRight(moveVec.x);
        controlsFP.moveForward(moveVec.z);
        const obj = controlsFP.getObject();
        obj.position.y = Math.max(1.0, obj.position.y);
      }
    }
  })();
}
</script>
</body>
</html>
