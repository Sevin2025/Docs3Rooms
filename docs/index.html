<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Галерея — Три Зала</title>
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#eee;font-family:Arial,sans-serif;}
canvas{display:block;}
#ui{
  position:fixed;top:10px;left:10px;z-index:20;
  background:rgba(255,255,255,0.9);padding:10px;border-radius:8px;
  box-shadow:0 2px 8px rgba(0,0,0,0.25);
}
#ui button{margin:3px;}
#hint{
  position:fixed;bottom:20px;left:50%;transform:translateX(-50%);
  background:rgba(0,0,0,0.6);color:#fff;padding:6px 12px;border-radius:20px;z-index:15;
}
#desc{
  position:fixed;bottom:10px;left:10px;max-width:300px;
  background:rgba(0,0,0,0.75);color:#fff;padding:8px;border-radius:8px;
  display:none;
}
</style>
</head>
<body>
<div id="ui">
  <b>3D Галерея</b><br>
  <button id="room1">Зал 1</button>
  <button id="room2">Зал 2</button>
  <button id="room3">Зал 3</button>
  <button id="reset">Сброс</button>
</div>
<div id="hint">Клик — управление мышью (Pointer Lock). ESC — выход.</div>
<div id="desc"><div id="title"></div><div id="text"></div></div>

<script type="module">
import * as THREE from './assets/three/three.module.js';
import { PointerLockControls } from './assets/three/PointerLockControls.js';

const ASSETS = './assets/';
const roomSize = { w:10, d:10, h:4 };
const roomGap = 4;  // расстояние между залами
const roomCount = 3;
const cameraHeight = 1.6;

let scene, camera, renderer, controls;
let paintings = [];
let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let INTERSECTED = null;
let moving = false;

init();

async function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xdddddd);

  camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
  camera.position.set(-7, cameraHeight, 0);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
  scene.add(hemi);

  buildRooms();
  await loadPaintings();

  controls = new PointerLockControls(camera, renderer.domElement);
  renderer.domElement.addEventListener('click', ()=>controls.lock());
  document.getElementById('hint').onclick=()=>controls.lock();
  controls.addEventListener('lock',()=>document.getElementById('hint').style.display='none');
  controls.addEventListener('unlock',()=>document.getElementById('hint').style.display='block');

  setupMovement();
  setupButtons();

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('click', onClick);

  animate();
}

function buildRooms(){
  const wallMat = new THREE.MeshStandardMaterial({color:0xe6e6e6,side:THREE.DoubleSide});
  const floorMat = new THREE.MeshStandardMaterial({color:0x8B4513,side:THREE.DoubleSide});
  const ceilMat = new THREE.MeshStandardMaterial({color:0xffffff,side:THREE.DoubleSide});

  for(let i=0;i<roomCount;i++){
    const group = new THREE.Group();
    const baseX = i*(roomSize.w+roomGap) - ((roomCount-1)*(roomSize.w+roomGap))/2;
    group.position.x = baseX;

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.d), floorMat);
    floor.rotation.x = -Math.PI/2; floor.position.y=0;
    const ceil = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.d), ceilMat);
    ceil.rotation.x = Math.PI/2; ceil.position.y=roomSize.h;

    const back = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.h), wallMat);
    back.position.set(0,roomSize.h/2,-roomSize.d/2);
    const front = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w,roomSize.h), wallMat);
    front.position.set(0,roomSize.h/2,roomSize.d/2); front.rotation.y=Math.PI;
    const left = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d,roomSize.h), wallMat);
    left.position.set(-roomSize.w/2,roomSize.h/2,0); left.rotation.y=Math.PI/2;
    const right = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d,roomSize.h), wallMat);
    right.position.set(roomSize.w/2,roomSize.h/2,0); right.rotation.y=-Math.PI/2;

    group.add(floor, ceil, back, front, left, right);
    scene.add(group);
  }
}

async function loadPaintings(){
  const loader = new THREE.TextureLoader();
  const manifest = await (await fetch(ASSETS+'manifest.json')).json();
  const desc = await (await fetch(ASSETS+'descriptions.json')).json();

  const rooms = ['room1','room2','room3'];
  for(let r=0;r<rooms.length;r++){
    const list = manifest[rooms[r]] || [];
    for(let i=0;i<list.length;i++){
      const file = list[i];
      const tex = await new Promise((res,rej)=>loader.load(ASSETS+file,res,undefined,rej));
      const aspect = tex.image.width/tex.image.height;
      const h = 1.2, w = h * aspect;
      const mat = new THREE.MeshStandardMaterial({map:tex});
      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w,h), mat);

      // равномерно распределим по стенам
      const perWall = Math.ceil(list.length/4);
      const wall = Math.floor(i/perWall)%4;
      const idx = i%perWall;
      const margin = 0.5;
      const usable = roomSize.w - 2*margin;
      const offset = -usable/2 + (idx+0.5)*(usable/Math.max(1,perWall));

      const cx = r*(roomSize.w+roomGap) - ((roomCount-1)*(roomSize.w+roomGap))/2;
      let px=cx,pz=0,ry=0;
      if(wall===0){px+=offset;pz=-roomSize.d/2+0.05;ry=0;}
      else if(wall===1){px+=offset;pz=roomSize.d/2-0.05;ry=Math.PI;}
      else if(wall===2){px=cx-roomSize.w/2+0.05;pz=offset;ry=Math.PI/2;}
      else{px=cx+roomSize.w/2-0.05;pz=offset;ry=-Math.PI/2;}
      mesh.position.set(px,1.6,pz);
      mesh.rotation.y = ry;
      mesh.userData = {file,meta:desc[file]||{}};
      paintings.push(mesh);
      scene.add(mesh);
    }
  }
}

function setupButtons(){
  document.getElementById('room1').onclick=()=>moveToRoom(1);
  document.getElementById('room2').onclick=()=>moveToRoom(2);
  document.getElementById('room3').onclick=()=>moveToRoom(3);
  document.getElementById('reset').onclick=()=>camera.position.set(-7,cameraHeight,0);
}

function moveToRoom(n){
  if(moving)return;
  const targetX = (n-1)*(roomSize.w+roomGap) - ((roomCount-1)*(roomSize.w+roomGap))/2;
  const start = camera.position.clone();
  const target = new THREE.Vector3(targetX, cameraHeight, 0);
  const startQ = camera.quaternion.clone();
  const endQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(0,0,0));
  let t=0; moving=true;
  function step(){
    t+=0.016/1.5; if(t>1)t=1;
    camera.position.lerpVectors(start,target,t);
    THREE.Quaternion.slerp(startQ,endQ,camera.quaternion,t);
    if(t<1)requestAnimationFrame(step); else moving=false;
  }
  step();
}

function onMouseMove(e){
  mouse.x = (e.clientX/innerWidth)*2 - 1;
  mouse.y = -(e.clientY/innerHeight)*2 + 1;
}

function onClick(){
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(paintings,true);
  if(intersects.length>0){
    focusPainting(intersects[0].object);
  }
}

function focusPainting(p){
  if(moving)return;
  moving=true;
  const dist = 2;
  const forward = new THREE.Vector3(0,0,1).applyQuaternion(p.quaternion).normalize();
  const target = p.position.clone().addScaledVector(forward, dist);
  target.y = cameraHeight;
  const start = camera.position.clone();
  const startQ = camera.quaternion.clone();
  const lookQ = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(camera.position,p.position,camera.up));
  let t=0;
  function step(){
    t+=0.016/1.5; if(t>1)t=1;
    camera.position.lerpVectors(start,target,t);
    THREE.Quaternion.slerp(startQ,lookQ,camera.quaternion,t);
    if(t<1)requestAnimationFrame(step); else moving=false;
  }
  step();

  // показать описание
  const box=document.getElementById('desc');
  document.getElementById('title').textContent = p.userData.meta.title || p.userData.file;
  document.getElementById('text').textContent = p.userData.meta.description || 'Описание отсутствует';
  box.style.display='block';
  setTimeout(()=>box.style.display='none',8000);
}

function setupMovement(){
  const move={f:0,b:0,l:0,r:0};
  const dir=new THREE.Vector3();
  document.addEventListener('keydown',e=>{
    if(e.code==='KeyW')move.f=1;
    if(e.code==='KeyS')move.b=1;
    if(e.code==='KeyA')move.l=1;
    if(e.code==='KeyD')move.r=1;
  });
  document.addEventListener('keyup',e=>{
    if(e.code==='KeyW')move.f=0;
    if(e.code==='KeyS')move.b=0;
    if(e.code==='KeyA')move.l=0;
    if(e.code==='KeyD')move.r=0;
  });
  const speed=3;
  function loop(){
    requestAnimationFrame(loop);
    if(controls.isLocked && !moving){
      dir.z=move.f-move.b; dir.x=move.r-move.l; dir.normalize();
      if(dir.lengthSq()>0){
        controls.moveRight(dir.x*speed*0.016);
        controls.moveForward(dir.z*speed*0.016);
      }
    }
  }
  loop();
}

function animate(){
  requestAnimationFrame(animate);
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(paintings,true);
  if(intersects.length>0){
    if(INTERSECTED!==intersects[0].object){
      if(INTERSECTED?.material?.emissive)INTERSECTED.material.emissive.setHex(0);
      INTERSECTED=intersects[0].object;
      if(INTERSECTED.material.emissive===undefined)INTERSECTED.material.emissive=new THREE.Color(0);
      INTERSECTED.material.emissive.setHex(0x222222);
    }
  }else{
    if(INTERSECTED?.material?.emissive)INTERSECTED.material.emissive.setHex(0);
    INTERSECTED=null;
  }
  renderer.render(scene,camera);
}
</script>
</body>
</html>
