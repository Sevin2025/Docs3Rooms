<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>3D-галерея (управление камерой с ограничениями)</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#ddd;font-family:Arial}
  canvas{display:block}
  #ui{position:fixed;top:10px;left:10px;z-index:10;background:rgba(255,255,255,0.9);
      padding:8px 12px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.3)}
  #ui button{margin-top:5px;padding:5px 8px;border:none;border-radius:6px;background:#444;color:#fff;cursor:pointer}
  .paintingLabel{position:fixed;transform:translate(-50%,-50%);pointer-events:none;background:rgba(255,255,255,0.9);
      padding:3px 5px;border-radius:4px;font-size:12px;z-index:5}
</style>
</head>
<body>
<div id="ui">
  <strong>3D-галерея</strong><br>
  <small>WASD — движение, мышь — обзор (горизонтально).</small><br>
  <button id="toggleLabels">Скрыть названия</button>
</div>

<script type="module">
import * as THREE from './assets/three/three.module.js';

let scene, camera, renderer;
let yaw=0, pitch=0;
let keys={w:0,a:0,s:0,d:0};
let raycaster=new THREE.Raycaster();
let paintings=[];
let labelsVisible=true;
let currentTarget=null;
let room={width:12,depth:12,height:3.2};
let minWallDist=1.0; // минимальное расстояние до стен
let movingToPainting=false;

init();
animate();

async function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0xdddddd);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.outputEncoding=THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  camera=new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,100);
  camera.position.set(0,1.6,0);

  // свет
  scene.add(new THREE.AmbientLight(0xffffff,0.9));
  const dir=new THREE.DirectionalLight(0xffffff,0.6);
  dir.position.set(5,10,5);
  scene.add(dir);

  makeRoom();

  await loadPaintings();

  window.addEventListener('resize',onResize);
  document.addEventListener('keydown',e=>{if(keys[e.key.toLowerCase()]!==undefined)keys[e.key.toLowerCase()]=1;});
  document.addEventListener('keyup',e=>{if(keys[e.key.toLowerCase()]!==undefined)keys[e.key.toLowerCase()]=0;});
  document.addEventListener('mousemove',onMouseMove);
  document.addEventListener('click',onClick);

  document.getElementById('toggleLabels').onclick=()=>{
    labelsVisible=!labelsVisible;
    document.getElementById('toggleLabels').innerText=labelsVisible?'Скрыть названия':'Показать названия';
    paintings.forEach(p=>p.label.style.display=labelsVisible?'block':'none');
  };
}

function makeRoom(){
  const floorMat=new THREE.MeshStandardMaterial({color:0xD2B48C,side:THREE.DoubleSide});
  const wallMat=new THREE.MeshStandardMaterial({color:0xE6E6E6,side:THREE.DoubleSide});
  const backMat=new THREE.MeshStandardMaterial({color:0x555555,side:THREE.DoubleSide});
  const ceilMat=new THREE.MeshStandardMaterial({color:0xffffff,side:THREE.DoubleSide});

  const floor=new THREE.Mesh(new THREE.PlaneGeometry(room.width,room.depth),floorMat);
  floor.rotation.x=-Math.PI/2;floor.position.y=0;scene.add(floor);
  const ceil=new THREE.Mesh(new THREE.PlaneGeometry(room.width,room.depth),ceilMat);
  ceil.rotation.x=Math.PI/2;ceil.position.y=room.height;scene.add(ceil);

  const front=new THREE.Mesh(new THREE.PlaneGeometry(room.width,room.height),wallMat);
  front.position.set(0,room.height/2,-room.depth/2);scene.add(front);

  const back=new THREE.Mesh(new THREE.PlaneGeometry(room.width,room.height),backMat);
  back.position.set(0,room.height/2,room.depth/2);back.rotation.y=Math.PI;scene.add(back);

  const left=new THREE.Mesh(new THREE.PlaneGeometry(room.depth,room.height),wallMat);
  left.position.set(-room.width/2,room.height/2,0);left.rotation.y=Math.PI/2;scene.add(left);

  const right=new THREE.Mesh(new THREE.PlaneGeometry(room.depth,room.height),wallMat);
  right.position.set(room.width/2,room.height/2,0);right.rotation.y=-Math.PI/2;scene.add(right);
}

async function loadPaintings(){
  // Пример (замени под manifest.json):
  const data={
    room1:["paintingA.jpg"],
    room2:["paintingG.jpg"],
    room3:["paintingS.jpg"]
  };
  const loader=new THREE.TextureLoader();

  // --- room1 (левая стена) ---
  const leftTex=await loader.loadAsync('./assets/paintingA.jpg');
  createPainting(leftTex,-room.width/2+0.05,1.6,0,Math.PI/2);
  // --- room2 (передняя стена) ---
  const frontTex=await loader.loadAsync('./assets/paintingG.jpg');
  createPainting(frontTex,0,1.6,-room.depth/2+0.05,Math.PI);
  // --- room3 (правая стена) ---
  const rightTex=await loader.loadAsync('./assets/paintingS.jpg');
  createPainting(rightTex,room.width/2-0.05,1.6,0,-Math.PI/2);
}

function createPainting(tex,x,y,z,rotY){
  tex.encoding=THREE.sRGBEncoding;
  const aspect=tex.image.width/tex.image.height;
  const height=1.2,width=height*aspect;
  const geom=new THREE.PlaneGeometry(width,height);
  const mat=new THREE.MeshStandardMaterial({map:tex});
  const mesh=new THREE.Mesh(geom,mat);
  mesh.position.set(x,y,z);
  mesh.rotation.y=rotY;
  mesh.translateZ(0.02);
  scene.add(mesh);
  paintings.push({mesh,rotY,label:addLabel(mesh,tex.image.src.split('/').pop())});
}

function addLabel(mesh,name){
  const el=document.createElement('div');
  el.className='paintingLabel';
  el.textContent=name;
  document.body.appendChild(el);
  return el;
}

function onMouseMove(e){
  yaw-=e.movementX*0.002;
  pitch=0; // блокируем вертикальный наклон
  camera.rotation.set(pitch,yaw,0);
}

function onClick(e){
  // определить, наведена ли мышь на картину
  const mouse=new THREE.Vector2((e.clientX/window.innerWidth)*2-1,-(e.clientY/window.innerHeight)*2+1);
  raycaster.setFromCamera(mouse,camera);
  const hits=raycaster.intersectObjects(paintings.map(p=>p.mesh),true);
  if(hits.length){
    const hit=hits[0].object;
    const entry=paintings.find(p=>p.mesh===hit);
    moveToPainting(entry);
  }else{
    currentTarget=null;
  }
}

function moveToPainting(entry){
  const worldPos=new THREE.Vector3();
  entry.mesh.getWorldPosition(worldPos);
  const normal=new THREE.Vector3(0,0,1).applyEuler(entry.mesh.rotation);
  // направление к камере должно быть перпендикулярно стене
  const targetPos=worldPos.clone().addScaledVector(normal,-minWallDist);
  targetPos.y=1.6;
  currentTarget={pos:targetPos,look:worldPos};
  movingToPainting=true;
}

function animate(){
  requestAnimationFrame(animate);
  updateMovement();
  updateCameraTarget();
  updateLabels();
  renderer.render(scene,camera);
}

function updateMovement(){
  const speed=0.05;
  const forward=new THREE.Vector3(Math.sin(yaw),0,-Math.cos(yaw));
  const right=new THREE.Vector3(forward.z,0,-forward.x);
  let move=new THREE.Vector3();
  if(keys.w)move.add(forward);
  if(keys.s)move.addScaledVector(forward,-1);
  if(keys.a)move.addScaledVector(right,-1);
  if(keys.d)move.add(right);
  move.normalize().multiplyScalar(speed);
  camera.position.add(move);
  // --- ограничение границ комнаты ---
  const limitX=(room.width/2)-minWallDist;
  const limitZ=(room.depth/2)-minWallDist;
  camera.position.x=Math.max(-limitX,Math.min(limitX,camera.position.x));
  camera.position.z=Math.max(-limitZ,Math.min(limitZ,camera.position.z));
}

function updateCameraTarget(){
  if(currentTarget){
    const dir=currentTarget.pos.clone().sub(camera.position);
    if(dir.length()>0.05){
      camera.position.addScaledVector(dir.normalize(),0.05);
      camera.lookAt(currentTarget.look);
    }else{
      movingToPainting=false;
      currentTarget=null;
    }
  }
}

function updateLabels(){
  paintings.forEach(p=>{
    const pos=new THREE.Vector3();
    p.mesh.getWorldPosition(pos);
    pos.project(camera);
    const x=(pos.x*0.5+0.5)*innerWidth;
    const y=(-pos.y*0.5+0.5)*innerHeight;
    p.label.style.left=x+'px';
    p.label.style.top=y+'px';
    p.label.style.display=labelsVisible?'block':'none';
  });
}

function onResize(){
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
}
</script>
</body>
</html>
