<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Виртуальная 3D-галерея — Sergeywieden</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#eee}
#overlayUI{
  position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);
  padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
}
#descriptionBox{
  position:fixed;left:12px;bottom:12px;z-index:30;
  background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
  max-width:40%;display:none;
}
#descTitle{font-weight:700;margin-bottom:6px}
#enterHint{
  position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
  background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
}
.paintingLabel{
  pointer-events:none;
  background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
  position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:19;
}
canvas{display:block}
button, select, input{font-size:13px}
.roomButtons{margin-top:8px;display:flex;gap:6px}
.roomButtons button{padding:6px 8px;cursor:pointer}
.roomButtons button.active{background:#333;color:#fff;border-radius:4px}
</style>
</head>
<body>

<div id="overlayUI">
  <div><strong>3D-галерея</strong></div>
  <div style="font-size:13px;margin-top:6px">
    Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
    Управление: WASD + мышь. Клик на картину — описание.
  </div>
  <div style="margin-top:8px">
    <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
  </div>
  <div style="margin-top:6px">
    <button id="resetPos">Сброс позиции</button>
  </div>
  <div style="margin-top:6px">
    <label>Режим:
      <select id="moveMode">
        <option value="fp">1st-person</option>
        <option value="orbit">Orbit</option>
      </select>
    </label>
  </div>

  <div class="roomButtons" style="margin-top:6px">
    <button id="btnRoom1" data-room="1" class="active">Комната 1</button>
    <button id="btnRoom2" data-room="2">Комната 2</button>
    <button id="btnRoom3" data-room="3">Комната 3</button>
  </div>

  <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
</div>

<div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
<div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выйти.</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

const ASSETS_BASE = './assets/'; 
const MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
const DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let paintingsGroup = new THREE.Group();        // содержит все картины и рамки
let paintingPlanes = [];                       // список плоскостей картин (для меток и поиска)
let INTERSECTED = null;
const roomCount = 3;
const roomSize = {w:12, h:4, d:12};
let loadTotal = 0, loadDone = 0;
let roomsGroup;                                // глобальная переменная для группы комнат
let currentRoom = 1;

init();

async function init(){
  setLoadStatus('Загрузка файлов...');
  try{
    const [manifest, descriptions] = await Promise.all([fetchJSON(MANIFEST_PATH), fetchJSON(DESCRIPTIONS_PATH)]);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 0);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,5);
    scene.add(amb, dir);

    // создаём комнаты и сохраняем глобально
    roomsGroup = new THREE.Group();
    const gap = 2;
    for(let i=0;i<roomCount;i++){
      const room = new THREE.Group();
      const xOffset = i * (roomSize.w + gap);
      room.position.set(xOffset, 0, 0);
      room.name = `room${i+1}`;
      addRoomGeometry(room);
      roomsGroup.add(room);
    }
    roomsGroup.position.x = -((roomCount-1)*(roomSize.w+gap))/2;
    scene.add(roomsGroup);

    // добавим группу картин отдельно (позиции картин рассчитаны глобально)
    scene.add(paintingsGroup);

    await placePaintings(manifest, descriptions);

    controlsFP = new PointerLockControls(camera, renderer.domElement);
    controlsOrbit = new OrbitControls(camera, renderer.domElement);
    controlsOrbit.enabled = false;
    currentControls = controlsFP;

    renderer.domElement.addEventListener('click', ()=>{ 
      if(document.getElementById('moveMode').value==='fp'){
        controlsFP.lock();
        document.getElementById('enterHint').style.display='none';
      }
    });

    window.addEventListener('resize', onResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('click', onClick);
    document.getElementById('showLabels').addEventListener('change', ev=>toggleLabels(ev.target.checked));
    document.getElementById('resetPos').addEventListener('click', ()=>{ camera.position.set(0,1.6,0); camera.rotation.set(0,0,0); });
    document.getElementById('moveMode').addEventListener('change', ev=>{ ev.target.value==='orbit'?switchOrbit():switchFP(); });

    // кнопки выбора комнаты
    document.getElementById('btnRoom1').addEventListener('click', ()=>selectRoom(1));
    document.getElementById('btnRoom2').addEventListener('click', ()=>selectRoom(2));
    document.getElementById('btnRoom3').addEventListener('click', ()=>selectRoom(3));

    setupWASD();
    // по умолчанию показываем комнату 1
    selectRoom(1);

    animate();
    setLoadStatus('Готово');
  }catch(err){
    console.error(err);
    setLoadStatus('Ошибка: '+(err.message||err));
  }
}

async function fetchJSON(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error('Не удалось загрузить '+url);
  return r.json();
}

function setLoadStatus(text){ const el=document.getElementById('loadStatus'); if(el) el.innerText=text; }

function addRoomGeometry(room){
  const floorColor=0xD2B48C, wallColor=0xE6E6E6, ceilingColor=0xFFFFFF;
  const floorMat = new THREE.MeshStandardMaterial({color: floorColor, side: THREE.DoubleSide});
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), floorMat);
  floor.rotation.x = -Math.PI/2; floor.position.y=0; room.add(floor);
  const ceilMat = new THREE.MeshStandardMaterial({color: ceilingColor, side: THREE.DoubleSide});
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), ceilMat);
  ceiling.rotation.x=Math.PI/2; ceiling.position.y=roomSize.h; room.add(ceiling);
  const wallMat = new THREE.MeshStandardMaterial({color: wallColor, side: THREE.DoubleSide});
  const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
  wallBack.position.set(0,roomSize.h/2,-roomSize.d/2);
  const wallFront = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
  wallFront.position.set(0,roomSize.h/2,roomSize.d/2); wallFront.rotateY(Math.PI);
  const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
  wallLeft.position.set(-roomSize.w/2,roomSize.h/2,0); wallLeft.rotateY(Math.PI/2);
  const wallRight = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
  wallRight.position.set(roomSize.w/2,roomSize.h/2,0); wallRight.rotateY(-Math.PI/2);
  room.add(wallBack, wallFront, wallLeft, wallRight);
}

async function placePaintings(manifest, descriptions){
  const loader = new THREE.TextureLoader();
  const keys=['room1','room2','room3'];
  loadTotal=0; loadDone=0; keys.forEach(k=>{ if(Array.isArray(manifest[k])) loadTotal+=manifest[k].length; });
  if(loadTotal===0) loadTotal=1;

  for(let r=0;r<3;r++){
    const roomKey=keys[r];
    const list=manifest[roomKey]||[];
    for(let i=0;i<list.length;i++){
      const fname=list[i];
      const url=ASSETS_BASE+fname;
      try{
        const tex=await new Promise((res,rej)=>loader.load(url,res,undefined,rej));
        tex.encoding=THREE.sRGBEncoding;
        const aspect = tex.image.width/tex.image.height;
        const height = 1.0, width = Math.max(0.3,height*aspect);
        const mat = new THREE.MeshStandardMaterial({map:tex});
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(width,height), mat);

        // расположение по стенам (по той же логике что и раньше)
        const perWall=Math.ceil(list.length/4);
        const wallIndex=Math.floor(i/perWall)%4;
        const indexOnWall=i%perWall;
        const margin=0.5;
        const usableLen=roomSize.w-2*margin;
        let along=-usableLen/2 + (indexOnWall+0.5)*(usableLen/Math.max(1,perWall));
        const gap=2;
        const roomCenterX=r*(roomSize.w+gap)-((roomCount-1)*(roomSize.w+gap))/2;
        let px=roomCenterX, pz=0, rotY=0, py=1.6;
        if(wallIndex===0){ px+=along; pz=-roomSize.d/2+0.01; rotY=0; }
        else if(wallIndex===1){ px+=along; pz=roomSize.d/2-0.01; rotY=Math.PI; }
        else if(wallIndex===2){ px=roomCenterX-roomSize.w/2+0.01; pz=along; rotY=Math.PI/2; }
        else{ px=roomCenterX+roomSize.w/2-0.01; pz=along; rotY=-Math.PI/2; }

        plane.position.set(px,py,pz); plane.rotation.y=rotY;
        plane.userData={file:fname,room:r+1,meta:descriptions[fname]||{}};

        const frameThickness=0.05, frameDepth=0.02;
        const frameGeom=new THREE.BoxGeometry(width+frameThickness,height+frameThickness,frameDepth);
        const frameMat=new THREE.MeshStandardMaterial({color:0x6b4226});
        const frame=new THREE.Mesh(frameGeom,frameMat);
        frame.position.copy(plane.position); frame.rotation.copy(plane.rotation);
        frame.translateZ(-frameDepth/2-0.005);
        // присваиваем frame тот же userData, чтобы клики на рамку тоже работали
        frame.userData = Object.assign({}, plane.userData);

        // создаём DOM-метку
        const label=createLabel(fname);
        plane.userData.labelEl=label; frame.userData.labelEl=label;

        // добавляем всё в общую группу картин
        paintingsGroup.add(frame); paintingsGroup.add(plane);

        // запоминаем только плоскость картины для меток/описания (plane — основной объект)
        paintingPlanes.push({mesh:plane,id:fname,meta:plane.userData.meta});

      }catch(err){ console.warn('Не удалось загрузить',url,err); }
      finally{ loadDone++; setLoadStatus(Math.round(loadDone/loadTotal*100)+'%'); }
    }
  }
}

function createLabel(text){
  const el=document.createElement('div'); el.className='paintingLabel'; el.innerText=text;
  el.style.display=document.getElementById('showLabels').checked?'block':'none';
  document.body.appendChild(el); return el;
}

function toggleLabels(show){ paintingPlanes.forEach(p=>{ if(p.mesh.userData.labelEl)p.mesh.userData.labelEl.style.display=show?'block':'none'; }); }

function onMouseMove(e){ mouse.x=(e.clientX/innerWidth)*2-1; mouse.y=-(e.clientY/innerHeight)*2+1; }

function onClick(){ 
  // клики для описания картин
  raycaster.setFromCamera(mouse,camera);
  // пересекаем все объекты в группе картин
  const intersects=raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.geometry),true);
  if(intersects.length>0){
    // берём первый видимый объект, игнорируем невидимые
    const first = intersects.find(iv=>iv.object.visible && iv.object.userData);
    if(first) showDescription(first.object.userData);
  }
}

function showDescription(userData){
  if(!userData)return;
  const box=document.getElementById('descriptionBox');
  document.getElementById('descTitle').innerText=userData.meta?.title||userData.file||'Картина';
  const author=userData.meta?.author?('\nАвтор: '+userData.meta.author):'';
  document.getElementById('descText').innerText=(userData.meta?.description||'Описание отсутствует')+author;
  box.style.display='block';
  setTimeout(()=>box.style.display='none',15000);
}

function switchOrbit(){ if(controlsFP.unlock) controlsFP.unlock(); controlsOrbit.enabled=true; currentControls=controlsOrbit; }
function switchFP(){ controlsOrbit.enabled=false; currentControls=controlsFP; }

function animate(){
  requestAnimationFrame(animate);
  if(currentControls===controlsOrbit) controlsOrbit.update();

  // подсветка наведённого
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.material && ch.visible), true);
  if(intersects.length>0){
    if(INTERSECTED!==intersects[0].object){
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED=intersects[0].object;
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x222222);
    }
  }else{
    if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED=null;
  }

  // обновляем позиции меток только для видимых плоскостей
  paintingPlanes.forEach(p=>{
    if(p.mesh.userData.labelEl && p.mesh.visible){
      updateLabelPosition(p.mesh);
      p.mesh.userData.labelEl.style.display=document.getElementById('showLabels').checked?'block':'none';
    } else if(p.mesh.userData.labelEl){
      p.mesh.userData.labelEl.style.display='none';
    }
  });

  renderer.render(scene,camera);
}

function updateLabelPosition(mesh){
  const el = mesh.userData.labelEl;
  if(!el) return;
  const pos = new THREE.Vector3();
  mesh.getWorldPosition(pos);
  pos.project(camera);
  const x = (pos.x*0.5+0.5)*innerWidth;
  const y = (-pos.y*0.5+0.5)*innerHeight;
  el.style.left=x+'px'; el.style.top=y+'px';
}

function onResize(){ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); }

function setupWASD(){
  const move={forward:false,back:false,left:false,right:false};
  const direction=new THREE.Vector3();
  const speed=3.0;

  document.addEventListener('keydown', e=>{
    if(e.code==='KeyW') move.forward=true;
    if(e.code==='KeyS') move.back=true;
    if(e.code==='KeyA') move.left=true;
    if(e.code==='KeyD') move.right=true;
  });
  document.addEventListener('keyup', e=>{
    if(e.code==='KeyW') move.forward=false;
    if(e.code==='KeyS') move.back=false;
    if(e.code==='KeyA') move.left=false;
    if(e.code==='KeyD') move.right=false;
  });

  (function tick(){
    requestAnimationFrame(tick);
    if(currentControls===controlsFP && controlsFP.isLocked===true){
      const delta=0.016;
      direction.z=Number(move.forward)-Number(move.back);
      direction.x=Number(move.right)-Number(move.left);
      direction.normalize();
      if(direction.lengthSq()>0){
        const moveVec=new THREE.Vector3(direction.x,0,direction.z).multiplyScalar(speed*delta);
        controlsFP.moveRight(moveVec.x);
        controlsFP.moveForward(moveVec.z);
        const obj=controlsFP.getObject();
        obj.position.y=Math.max(1.0,obj.position.y);
      }
    }
  })();
}

/* ---------- функция переключения комнат ---------- 
   Действия:
    - скрыть все картины/рамки, кроме тех, что в нужной комнате
    - обновить активную кнопку
    - переместить камеру в центр выбранной комнаты (с небольшим отступом назад)
*/
function selectRoom(n){
  currentRoom = n;
  // прячем/показываем картины и рамки по userData.room
  paintingsGroup.children.forEach(ch=>{
    const r = ch.userData?.room;
    if(typeof r === 'number'){
      ch.visible = (r === n);
    } else {
      // объекты без userData.room оставляем видимыми (на всякий случай)
      ch.visible = true;
    }
  });

  // обновляем видимость меток
  paintingPlanes.forEach(p=>{
    if(p.mesh.userData.labelEl){
      p.mesh.userData.labelEl.style.display = (p.mesh.userData.room === n && document.getElementById('showLabels').checked) ? 'block' : 'none';
    }
  });

  // поставить камеру в центр комнаты (немного отодвинуть назад от центра)
  const gap = 2;
  const roomCenterX = (n-1)*(roomSize.w+gap) - ((roomCount-1)*(roomSize.w+gap))/2;
  // камеру ставим на 0, 1.6, + (d/2 - 1.5) чтобы смотреть внутрь комнаты
  camera.position.set(roomCenterX, 1.6, roomSize.d/2 - 1.8);
  // направим камеру в центр комнаты
  camera.lookAt(new THREE.Vector3(roomCenterX, 1.6, 0));

  // обновляем кнопки UI
  [1,2,3].forEach(i=>{
    const b = document.getElementById('btnRoom'+i);
    if(b) b.classList.toggle('active', i===n);
  });
}

</script>
</body>
</html>
