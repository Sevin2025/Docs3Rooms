<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Виртуальная 3D-галерея — Sergeywieden</title>
<style>
html,body{height:100%;margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#eee}
#overlayUI{
  position:fixed;right:12px;top:12px;z-index:20;background:rgba(255,255,255,0.95);
  padding:8px;border-radius:6px;box-shadow:0 2px 10px rgba(0,0,0,.2);max-width:320px;
}
#descriptionBox{
  position:fixed;left:12px;bottom:12px;z-index:30;
  background:rgba(0,0,0,0.85);color:#fff;padding:12px;border-radius:6px;
  max-width:40%;display:none;
}
#descTitle{font-weight:700;margin-bottom:6px}
#enterHint{
  position:fixed;left:50%;bottom:40px;transform:translateX(-50%);z-index:25;
  background:rgba(0,0,0,0.6);color:#fff;padding:8px 12px;border-radius:20px;
}
.paintingLabel{
  pointer-events:none;
  background:rgba(255,255,255,0.95);padding:4px 6px;border-radius:4px;font-size:12px;
  position:fixed;transform:translate(-50%,-50%);white-space:nowrap;z-index:19;
}
canvas{display:block}
button, select, input{font-size:13px}
</style>
</head>
<body>

<div id="overlayUI">
  <div><strong>3D-галерея</strong></div>
  <div style="font-size:13px;margin-top:6px">
    Комнаты: 1 (A*), 2 (G*), 3 (S*)<br/>
    Управление: WASD + мышь. Клик на картину — описание.
  </div>
  <div style="margin-top:8px">
    <label><input id="showLabels" type="checkbox" checked/> Показывать подписи</label>
  </div>
  <div style="margin-top:6px">
    <button id="resetPos">Сброс позиции</button>
  </div>
  <div style="margin-top:6px">
    <label>Режим:
      <select id="moveMode">
        <option value="fp">1st-person</option>
        <option value="orbit">Orbit</option>
      </select>
    </label>
  </div>
  <div style="margin-top:6px;font-size:12px;color:#666">Загрузка: <span id="loadStatus">0%</span></div>
</div>

<div id="descriptionBox"><div id="descTitle"></div><div id="descText" style="white-space:pre-wrap"></div></div>
<div id="enterHint">Клик по сцене, чтобы начать (Pointer Lock). ESC — выйти.</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js';
import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

const ASSETS_BASE = './assets/'; 
const MANIFEST_PATH = ASSETS_BASE + 'manifest.json';
const DESCRIPTIONS_PATH = ASSETS_BASE + 'descriptions.json';

let scene, camera, renderer, controlsFP, controlsOrbit, currentControls;
let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();
let paintingsGroup = new THREE.Group();
let paintingPlanes = [];
let INTERSECTED = null;
const roomCount = 3;
const roomSize = {w:12, h:4, d:12};
let loadTotal = 0, loadDone = 0;

init();

async function init(){
  setLoadStatus('Загрузка файлов...');
  try{
    const [manifest, descriptions] = await Promise.all([fetchJSON(MANIFEST_PATH), fetchJSON(DESCRIPTIONS_PATH)]);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 0);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    document.body.appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5,10,5);
    scene.add(amb, dir);

    const roomsGroup = new THREE.Group();
    const gap = 2;
    for(let i=0;i<roomCount;i++){
      const room = new THREE.Group();
      const xOffset = i * (roomSize.w + gap);
      room.position.set(xOffset, 0, 0);
      room.name = `room${i+1}`;
      addRoomGeometry(room);
      roomsGroup.add(room);
    }
    roomsGroup.position.x = -((roomCount-1)*(roomSize.w+gap))/2;
    scene.add(roomsGroup);

    await placePaintings(manifest, descriptions);
    scene.add(paintingsGroup);

    controlsFP = new PointerLockControls(camera, renderer.domElement);
    controlsOrbit = new OrbitControls(camera, renderer.domElement);
    controlsOrbit.enabled = false;
    currentControls = controlsFP;

    renderer.domElement.addEventListener('click', ()=>{
      if(document.getElementById('moveMode').value==='fp'){
        controlsFP.lock();
        document.getElementById('enterHint').style.display='none';
      }
    });

    window.addEventListener('resize', onResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('click', onClick);
    document.getElementById('showLabels').addEventListener('change', ev=>toggleLabels(ev.target.checked));
    document.getElementById('resetPos').addEventListener('click', ()=>{ camera.position.set(0,1.6,0); camera.rotation.set(0,0,0); });
    document.getElementById('moveMode').addEventListener('change', ev=>{ ev.target.value==='orbit'?switchOrbit():switchFP(); });

    setupWASD();
    animate();
    setLoadStatus('Готово');
  }catch(err){
    console.error(err);
    setLoadStatus('Ошибка: '+(err.message||err));
  }
}

async function fetchJSON(url){
  const r = await fetch(url);
  if(!r.ok) throw new Error('Не удалось загрузить '+url);
  return r.json();
}

function setLoadStatus(text){ const el=document.getElementById('loadStatus'); if(el) el.innerText=text; }

function addRoomGeometry(room){
  const floorColor=0xD2B48C, wallColor=0xE6E6E6, ceilingColor=0xFFFFFF;
  const floorMat = new THREE.MeshStandardMaterial({color: floorColor, side: THREE.DoubleSide});
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), floorMat);
  floor.rotation.x = -Math.PI/2; floor.position.y=0; room.add(floor);
  const ceilMat = new THREE.MeshStandardMaterial({color: ceilingColor, side: THREE.DoubleSide});
  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.d), ceilMat);
  ceiling.rotation.x=Math.PI/2; ceiling.position.y=roomSize.h; room.add(ceiling);
  const wallMat = new THREE.MeshStandardMaterial({color: wallColor, side: THREE.DoubleSide});
  const wallBack = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
  wallBack.position.set(0,roomSize.h/2,-roomSize.d/2);
  const wallFront = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.w, roomSize.h), wallMat);
  wallFront.position.set(0,roomSize.h/2,roomSize.d/2); wallFront.rotateY(Math.PI);
  const wallLeft = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
  wallLeft.position.set(-roomSize.w/2,roomSize.h/2,0); wallLeft.rotateY(Math.PI/2);
  const wallRight = new THREE.Mesh(new THREE.PlaneGeometry(roomSize.d, roomSize.h), wallMat);
  wallRight.position.set(roomSize.w/2,roomSize.h/2,0); wallRight.rotateY(-Math.PI/2);
  room.add(wallBack, wallFront, wallLeft, wallRight);
}

async function placePaintings(manifest, descriptions){
  const loader = new THREE.TextureLoader();
  const keys=['room1','room2','room3'];
  loadTotal=0; loadDone=0; keys.forEach(k=>{ if(Array.isArray(manifest[k])) loadTotal+=manifest[k].length; });
  if(loadTotal===0) loadTotal=1;

  for(let r=0;r<3;r++){
    const roomKey=keys[r];
    const list=manifest[roomKey]||[];
    for(let i=0;i<list.length;i++){
      const fname=list[i];
      const url=ASSETS_BASE+fname;
      try{
        const tex=await new Promise((res,rej)=>loader.load(url,res,undefined,rej));
        tex.encoding=THREE.sRGBEncoding;
        const aspect = tex.image.width/tex.image.height;
        const height = 1.0, width = Math.max(0.3,height*aspect);
        const mat = new THREE.MeshStandardMaterial({map:tex});
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(width,height), mat);

        const perWall=Math.ceil(list.length/4);
        const wallIndex=Math.floor(i/perWall)%4;
        const indexOnWall=i%perWall;
        const margin=0.5;
        const usableLen=roomSize.w-2*margin;
        let along=-usableLen/2 + (indexOnWall+0.5)*(usableLen/Math.max(1,perWall));
        const gap=2;
        const roomCenterX=r*(roomSize.w+gap)-((3-1)*(roomSize.w+gap))/2;
        let px=roomCenterX, pz=0, rotY=0, py=1.6;
        if(wallIndex===0){ px+=along; pz=-roomSize.d/2+0.01; rotY=0; }
        else if(wallIndex===1){ px+=along; pz=roomSize.d/2-0.01; rotY=Math.PI; }
        else if(wallIndex===2){ px=roomCenterX-roomSize.w/2+0.01; pz=along; rotY=Math.PI/2; }
        else{ px=roomCenterX+roomSize.w/2-0.01; pz=along; rotY=-Math.PI/2; }

        plane.position.set(px,py,pz); plane.rotation.y=rotY;
        plane.userData={file:fname,room:r+1,meta:descriptions[fname]||{}};

        const frameThickness=0.05, frameDepth=0.02;
        const frameGeom=new THREE.BoxGeometry(width+frameThickness,height+frameThickness,frameDepth);
        const frameMat=new THREE.MeshStandardMaterial({color:0x6b4226});
        const frame=new THREE.Mesh(frameGeom,frameMat);
        frame.position.copy(plane.position); frame.rotation.copy(plane.rotation);
        frame.translateZ(-frameDepth/2-0.005);

        const label=createLabel(fname);
        plane.userData.labelEl=label;

        paintingsGroup.add(frame); paintingsGroup.add(plane);
        paintingPlanes.push({mesh:plane,id:fname,meta:plane.userData.meta});
      }catch(err){ console.warn('Не удалось загрузить',url,err); }
      finally{ loadDone++; setLoadStatus(Math.round(loadDone/loadTotal*100)+'%'); }
    }
  }
}

function createLabel(text){
  const el=document.createElement('div'); el.className='paintingLabel'; el.innerText=text;
  el.style.display=document.getElementById('showLabels').checked?'block':'none';
  document.body.appendChild(el); return el;
}

function toggleLabels(show){ paintingPlanes.forEach(p=>{ if(p.mesh.userData.labelEl)p.mesh.userData.labelEl.style.display=show?'block':'none'; }); }

function onMouseMove(e){ mouse.x=(e.clientX/innerWidth)*2-1; mouse.y=-(e.clientY/innerHeight)*2+1; }

function onClick(){ 
  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.geometry),true);
  if(intersects.length>0) showDescription(intersects[0].object.userData);
}

function showDescription(userData){
  if(!userData)return;
  const box=document.getElementById('descriptionBox');
  document.getElementById('descTitle').innerText=userData.meta?.title||userData.file||'Картина';
  const author=userData.meta?.author?('\nАвтор: '+userData.meta.author):'';
  document.getElementById('descText').innerText=(userData.meta?.description||'Описание отсутствует')+author;
  box.style.display='block';
  setTimeout(()=>box.style.display='none',15000);
}

function switchOrbit(){ controlsFP.unlock && controlsFP.unlock(); controlsOrbit.enabled=true; currentControls=controlsOrbit; }
function switchFP(){ controlsOrbit.enabled=false; currentControls=controlsFP; }

function animate(){
  requestAnimationFrame(animate);
  if(currentControls===controlsOrbit) controlsOrbit.update();

  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(paintingsGroup.children.filter(ch=>ch.material), true);
  if(intersects.length>0){
    if(INTERSECTED!==intersects[0].object){
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
      INTERSECTED=intersects[0].object;
      if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x222222);
    }
  }else{
    if(INTERSECTED?.material?.emissive) INTERSECTED.material.emissive.setHex(0x000000);
    INTERSECTED=null;
  }

  paintingPlanes.forEach(p=>{ if(p.mesh.userData.labelEl && p.mesh.visible) updateLabelPosition(p.mesh); });
  renderer.render(scene,camera);
}

function updateLabelPosition(mesh){
  const el = mesh.userData.labelEl;
  if(!el) return;
  const pos = new THREE.Vector3();
  mesh.getWorldPosition(pos);
  pos.project(camera);
  const x = (pos.x*0.5+0.5)*innerWidth;
  const y = (-pos.y*0.5+0.5)*innerHeight;
  el.style.left=x+'px'; el.style.top=y+'px';
}

function onResize(){ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); }

function setupWASD(){
  const move={forward:false,back:false,left:false,right:false};
  const direction=new THREE.Vector3();
  const speed=3.0;

  document.addEventListener('keydown', e=>{
    if(e.code==='KeyW') move.forward=true;
    if(e.code==='KeyS') move.back=true;
    if(e.code==='KeyA') move.left=true;
    if(e.code==='KeyD') move.right=true;
  });
  document.addEventListener('keyup', e=>{
    if(e.code==='KeyW') move.forward=false;
    if(e.code==='KeyS') move.back=false;
    if(e.code==='KeyA') move.left=false;
    if(e.code==='KeyD') move.right=false;
  });

  (function tick(){
    requestAnimationFrame(tick);
    if(currentControls===controlsFP && controlsFP.isLocked===true){
      const delta=0.016;
      direction.z=Number(move.forward)-Number(move.back);
      direction.x=Number(move.right)-Number(move.left);
      direction.normalize();
      if(direction.lengthSq()>0){
        const moveVec=new THREE.Vector3(direction.x,0,direction.z).multiplyScalar(speed*delta);
        controlsFP.moveRight(moveVec.x);
        controlsFP.moveForward(moveVec.z);
        const obj=controlsFP.getObject();
        obj.position.y=Math.max(1.0,obj.position.y);
      }
    }
  })();
}
</script>
</body>
</html>
